// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bff.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bff_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bff_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "types.pb.h"
#include "agent.pb.h"
#include "simenv.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bff_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bff_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[24]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bff_2eproto;
namespace game {
namespace bff {
class AgentConfigMap;
struct AgentConfigMapDefaultTypeInternal;
extern AgentConfigMapDefaultTypeInternal _AgentConfigMap_default_instance_;
class AgentConfigMap_ConfigsEntry_DoNotUse;
struct AgentConfigMap_ConfigsEntry_DoNotUseDefaultTypeInternal;
extern AgentConfigMap_ConfigsEntry_DoNotUseDefaultTypeInternal _AgentConfigMap_ConfigsEntry_DoNotUse_default_instance_;
class AgentModeMap;
struct AgentModeMapDefaultTypeInternal;
extern AgentModeMapDefaultTypeInternal _AgentModeMap_default_instance_;
class AgentModeMap_ModesEntry_DoNotUse;
struct AgentModeMap_ModesEntry_DoNotUseDefaultTypeInternal;
extern AgentModeMap_ModesEntry_DoNotUseDefaultTypeInternal _AgentModeMap_ModesEntry_DoNotUse_default_instance_;
class CallDataMap;
struct CallDataMapDefaultTypeInternal;
extern CallDataMapDefaultTypeInternal _CallDataMap_default_instance_;
class CallDataMap_DataEntry_DoNotUse;
struct CallDataMap_DataEntry_DoNotUseDefaultTypeInternal;
extern CallDataMap_DataEntry_DoNotUseDefaultTypeInternal _CallDataMap_DataEntry_DoNotUse_default_instance_;
class ModelBufferMap;
struct ModelBufferMapDefaultTypeInternal;
extern ModelBufferMapDefaultTypeInternal _ModelBufferMap_default_instance_;
class ModelBufferMap_BuffersEntry_DoNotUse;
struct ModelBufferMap_BuffersEntry_DoNotUseDefaultTypeInternal;
extern ModelBufferMap_BuffersEntry_DoNotUseDefaultTypeInternal _ModelBufferMap_BuffersEntry_DoNotUse_default_instance_;
class ModelStatusMap;
struct ModelStatusMapDefaultTypeInternal;
extern ModelStatusMapDefaultTypeInternal _ModelStatusMap_default_instance_;
class ModelStatusMap_StatusEntry_DoNotUse;
struct ModelStatusMap_StatusEntry_DoNotUseDefaultTypeInternal;
extern ModelStatusMap_StatusEntry_DoNotUseDefaultTypeInternal _ModelStatusMap_StatusEntry_DoNotUse_default_instance_;
class ModelWeightsMap;
struct ModelWeightsMapDefaultTypeInternal;
extern ModelWeightsMapDefaultTypeInternal _ModelWeightsMap_default_instance_;
class ModelWeightsMap_WeightsEntry_DoNotUse;
struct ModelWeightsMap_WeightsEntry_DoNotUseDefaultTypeInternal;
extern ModelWeightsMap_WeightsEntry_DoNotUseDefaultTypeInternal _ModelWeightsMap_WeightsEntry_DoNotUse_default_instance_;
class ServiceIdList;
struct ServiceIdListDefaultTypeInternal;
extern ServiceIdListDefaultTypeInternal _ServiceIdList_default_instance_;
class ServiceInfo;
struct ServiceInfoDefaultTypeInternal;
extern ServiceInfoDefaultTypeInternal _ServiceInfo_default_instance_;
class ServiceInfoMap;
struct ServiceInfoMapDefaultTypeInternal;
extern ServiceInfoMapDefaultTypeInternal _ServiceInfoMap_default_instance_;
class ServiceInfoMap_ServicesEntry_DoNotUse;
struct ServiceInfoMap_ServicesEntry_DoNotUseDefaultTypeInternal;
extern ServiceInfoMap_ServicesEntry_DoNotUseDefaultTypeInternal _ServiceInfoMap_ServicesEntry_DoNotUse_default_instance_;
class ServiceStateMap;
struct ServiceStateMapDefaultTypeInternal;
extern ServiceStateMapDefaultTypeInternal _ServiceStateMap_default_instance_;
class ServiceStateMap_StatesEntry_DoNotUse;
struct ServiceStateMap_StatesEntry_DoNotUseDefaultTypeInternal;
extern ServiceStateMap_StatesEntry_DoNotUseDefaultTypeInternal _ServiceStateMap_StatesEntry_DoNotUse_default_instance_;
class SimCmdMap;
struct SimCmdMapDefaultTypeInternal;
extern SimCmdMapDefaultTypeInternal _SimCmdMap_default_instance_;
class SimCmdMap_CmdsEntry_DoNotUse;
struct SimCmdMap_CmdsEntry_DoNotUseDefaultTypeInternal;
extern SimCmdMap_CmdsEntry_DoNotUseDefaultTypeInternal _SimCmdMap_CmdsEntry_DoNotUse_default_instance_;
class SimInfoMap;
struct SimInfoMapDefaultTypeInternal;
extern SimInfoMapDefaultTypeInternal _SimInfoMap_default_instance_;
class SimInfoMap_InfosEntry_DoNotUse;
struct SimInfoMap_InfosEntry_DoNotUseDefaultTypeInternal;
extern SimInfoMap_InfosEntry_DoNotUseDefaultTypeInternal _SimInfoMap_InfosEntry_DoNotUse_default_instance_;
class SimenvConfigMap;
struct SimenvConfigMapDefaultTypeInternal;
extern SimenvConfigMapDefaultTypeInternal _SimenvConfigMap_default_instance_;
class SimenvConfigMap_ConfigsEntry_DoNotUse;
struct SimenvConfigMap_ConfigsEntry_DoNotUseDefaultTypeInternal;
extern SimenvConfigMap_ConfigsEntry_DoNotUseDefaultTypeInternal _SimenvConfigMap_ConfigsEntry_DoNotUse_default_instance_;
}  // namespace bff
}  // namespace game
PROTOBUF_NAMESPACE_OPEN
template<> ::game::bff::AgentConfigMap* Arena::CreateMaybeMessage<::game::bff::AgentConfigMap>(Arena*);
template<> ::game::bff::AgentConfigMap_ConfigsEntry_DoNotUse* Arena::CreateMaybeMessage<::game::bff::AgentConfigMap_ConfigsEntry_DoNotUse>(Arena*);
template<> ::game::bff::AgentModeMap* Arena::CreateMaybeMessage<::game::bff::AgentModeMap>(Arena*);
template<> ::game::bff::AgentModeMap_ModesEntry_DoNotUse* Arena::CreateMaybeMessage<::game::bff::AgentModeMap_ModesEntry_DoNotUse>(Arena*);
template<> ::game::bff::CallDataMap* Arena::CreateMaybeMessage<::game::bff::CallDataMap>(Arena*);
template<> ::game::bff::CallDataMap_DataEntry_DoNotUse* Arena::CreateMaybeMessage<::game::bff::CallDataMap_DataEntry_DoNotUse>(Arena*);
template<> ::game::bff::ModelBufferMap* Arena::CreateMaybeMessage<::game::bff::ModelBufferMap>(Arena*);
template<> ::game::bff::ModelBufferMap_BuffersEntry_DoNotUse* Arena::CreateMaybeMessage<::game::bff::ModelBufferMap_BuffersEntry_DoNotUse>(Arena*);
template<> ::game::bff::ModelStatusMap* Arena::CreateMaybeMessage<::game::bff::ModelStatusMap>(Arena*);
template<> ::game::bff::ModelStatusMap_StatusEntry_DoNotUse* Arena::CreateMaybeMessage<::game::bff::ModelStatusMap_StatusEntry_DoNotUse>(Arena*);
template<> ::game::bff::ModelWeightsMap* Arena::CreateMaybeMessage<::game::bff::ModelWeightsMap>(Arena*);
template<> ::game::bff::ModelWeightsMap_WeightsEntry_DoNotUse* Arena::CreateMaybeMessage<::game::bff::ModelWeightsMap_WeightsEntry_DoNotUse>(Arena*);
template<> ::game::bff::ServiceIdList* Arena::CreateMaybeMessage<::game::bff::ServiceIdList>(Arena*);
template<> ::game::bff::ServiceInfo* Arena::CreateMaybeMessage<::game::bff::ServiceInfo>(Arena*);
template<> ::game::bff::ServiceInfoMap* Arena::CreateMaybeMessage<::game::bff::ServiceInfoMap>(Arena*);
template<> ::game::bff::ServiceInfoMap_ServicesEntry_DoNotUse* Arena::CreateMaybeMessage<::game::bff::ServiceInfoMap_ServicesEntry_DoNotUse>(Arena*);
template<> ::game::bff::ServiceStateMap* Arena::CreateMaybeMessage<::game::bff::ServiceStateMap>(Arena*);
template<> ::game::bff::ServiceStateMap_StatesEntry_DoNotUse* Arena::CreateMaybeMessage<::game::bff::ServiceStateMap_StatesEntry_DoNotUse>(Arena*);
template<> ::game::bff::SimCmdMap* Arena::CreateMaybeMessage<::game::bff::SimCmdMap>(Arena*);
template<> ::game::bff::SimCmdMap_CmdsEntry_DoNotUse* Arena::CreateMaybeMessage<::game::bff::SimCmdMap_CmdsEntry_DoNotUse>(Arena*);
template<> ::game::bff::SimInfoMap* Arena::CreateMaybeMessage<::game::bff::SimInfoMap>(Arena*);
template<> ::game::bff::SimInfoMap_InfosEntry_DoNotUse* Arena::CreateMaybeMessage<::game::bff::SimInfoMap_InfosEntry_DoNotUse>(Arena*);
template<> ::game::bff::SimenvConfigMap* Arena::CreateMaybeMessage<::game::bff::SimenvConfigMap>(Arena*);
template<> ::game::bff::SimenvConfigMap_ConfigsEntry_DoNotUse* Arena::CreateMaybeMessage<::game::bff::SimenvConfigMap_ConfigsEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace game {
namespace bff {

// ===================================================================

class ServiceInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.bff.ServiceInfo) */ {
 public:
  inline ServiceInfo() : ServiceInfo(nullptr) {}
  ~ServiceInfo() override;
  explicit constexpr ServiceInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceInfo(const ServiceInfo& from);
  ServiceInfo(ServiceInfo&& from) noexcept
    : ServiceInfo() {
    *this = ::std::move(from);
  }

  inline ServiceInfo& operator=(const ServiceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceInfo& operator=(ServiceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceInfo* internal_default_instance() {
    return reinterpret_cast<const ServiceInfo*>(
               &_ServiceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ServiceInfo& a, ServiceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServiceInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.bff.ServiceInfo";
  }
  protected:
  explicit ServiceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kNameFieldNumber = 2,
    kHostFieldNumber = 3,
    kDescFieldNumber = 5,
    kPortFieldNumber = 4,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string host = 3;
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // string desc = 5;
  void clear_desc();
  const std::string& desc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_desc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_desc();
  PROTOBUF_NODISCARD std::string* release_desc();
  void set_allocated_desc(std::string* desc);
  private:
  const std::string& _internal_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desc(const std::string& value);
  std::string* _internal_mutable_desc();
  public:

  // uint32 port = 4;
  void clear_port();
  uint32_t port() const;
  void set_port(uint32_t value);
  private:
  uint32_t _internal_port() const;
  void _internal_set_port(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:game.bff.ServiceInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr desc_;
  uint32_t port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bff_2eproto;
};
// -------------------------------------------------------------------

class ServiceIdList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.bff.ServiceIdList) */ {
 public:
  inline ServiceIdList() : ServiceIdList(nullptr) {}
  ~ServiceIdList() override;
  explicit constexpr ServiceIdList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceIdList(const ServiceIdList& from);
  ServiceIdList(ServiceIdList&& from) noexcept
    : ServiceIdList() {
    *this = ::std::move(from);
  }

  inline ServiceIdList& operator=(const ServiceIdList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceIdList& operator=(ServiceIdList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceIdList& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceIdList* internal_default_instance() {
    return reinterpret_cast<const ServiceIdList*>(
               &_ServiceIdList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ServiceIdList& a, ServiceIdList& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceIdList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceIdList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceIdList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceIdList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceIdList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServiceIdList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceIdList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.bff.ServiceIdList";
  }
  protected:
  explicit ServiceIdList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdsFieldNumber = 1,
  };
  // repeated string ids = 1;
  int ids_size() const;
  private:
  int _internal_ids_size() const;
  public:
  void clear_ids();
  const std::string& ids(int index) const;
  std::string* mutable_ids(int index);
  void set_ids(int index, const std::string& value);
  void set_ids(int index, std::string&& value);
  void set_ids(int index, const char* value);
  void set_ids(int index, const char* value, size_t size);
  std::string* add_ids();
  void add_ids(const std::string& value);
  void add_ids(std::string&& value);
  void add_ids(const char* value);
  void add_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ids();
  private:
  const std::string& _internal_ids(int index) const;
  std::string* _internal_add_ids();
  public:

  // @@protoc_insertion_point(class_scope:game.bff.ServiceIdList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bff_2eproto;
};
// -------------------------------------------------------------------

class ServiceInfoMap_ServicesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ServiceInfoMap_ServicesEntry_DoNotUse, 
    std::string, ::game::bff::ServiceInfo,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ServiceInfoMap_ServicesEntry_DoNotUse, 
    std::string, ::game::bff::ServiceInfo,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ServiceInfoMap_ServicesEntry_DoNotUse();
  explicit constexpr ServiceInfoMap_ServicesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ServiceInfoMap_ServicesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ServiceInfoMap_ServicesEntry_DoNotUse& other);
  static const ServiceInfoMap_ServicesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ServiceInfoMap_ServicesEntry_DoNotUse*>(&_ServiceInfoMap_ServicesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "game.bff.ServiceInfoMap.ServicesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class ServiceInfoMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.bff.ServiceInfoMap) */ {
 public:
  inline ServiceInfoMap() : ServiceInfoMap(nullptr) {}
  ~ServiceInfoMap() override;
  explicit constexpr ServiceInfoMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceInfoMap(const ServiceInfoMap& from);
  ServiceInfoMap(ServiceInfoMap&& from) noexcept
    : ServiceInfoMap() {
    *this = ::std::move(from);
  }

  inline ServiceInfoMap& operator=(const ServiceInfoMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceInfoMap& operator=(ServiceInfoMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceInfoMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceInfoMap* internal_default_instance() {
    return reinterpret_cast<const ServiceInfoMap*>(
               &_ServiceInfoMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ServiceInfoMap& a, ServiceInfoMap& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceInfoMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceInfoMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceInfoMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceInfoMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceInfoMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServiceInfoMap& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceInfoMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.bff.ServiceInfoMap";
  }
  protected:
  explicit ServiceInfoMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kServicesFieldNumber = 1,
  };
  // map<string, .game.bff.ServiceInfo> services = 1;
  int services_size() const;
  private:
  int _internal_services_size() const;
  public:
  void clear_services();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::bff::ServiceInfo >&
      _internal_services() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::bff::ServiceInfo >*
      _internal_mutable_services();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::bff::ServiceInfo >&
      services() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::bff::ServiceInfo >*
      mutable_services();

  // @@protoc_insertion_point(class_scope:game.bff.ServiceInfoMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ServiceInfoMap_ServicesEntry_DoNotUse,
      std::string, ::game::bff::ServiceInfo,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> services_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bff_2eproto;
};
// -------------------------------------------------------------------

class ServiceStateMap_StatesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ServiceStateMap_StatesEntry_DoNotUse, 
    std::string, ::game::types::ServiceState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ServiceStateMap_StatesEntry_DoNotUse, 
    std::string, ::game::types::ServiceState,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ServiceStateMap_StatesEntry_DoNotUse();
  explicit constexpr ServiceStateMap_StatesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ServiceStateMap_StatesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ServiceStateMap_StatesEntry_DoNotUse& other);
  static const ServiceStateMap_StatesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ServiceStateMap_StatesEntry_DoNotUse*>(&_ServiceStateMap_StatesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "game.bff.ServiceStateMap.StatesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class ServiceStateMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.bff.ServiceStateMap) */ {
 public:
  inline ServiceStateMap() : ServiceStateMap(nullptr) {}
  ~ServiceStateMap() override;
  explicit constexpr ServiceStateMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceStateMap(const ServiceStateMap& from);
  ServiceStateMap(ServiceStateMap&& from) noexcept
    : ServiceStateMap() {
    *this = ::std::move(from);
  }

  inline ServiceStateMap& operator=(const ServiceStateMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceStateMap& operator=(ServiceStateMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceStateMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceStateMap* internal_default_instance() {
    return reinterpret_cast<const ServiceStateMap*>(
               &_ServiceStateMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ServiceStateMap& a, ServiceStateMap& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceStateMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceStateMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceStateMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceStateMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceStateMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServiceStateMap& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceStateMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.bff.ServiceStateMap";
  }
  protected:
  explicit ServiceStateMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kStatesFieldNumber = 1,
  };
  // map<string, .game.types.ServiceState> states = 1;
  int states_size() const;
  private:
  int _internal_states_size() const;
  public:
  void clear_states();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::types::ServiceState >&
      _internal_states() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::types::ServiceState >*
      _internal_mutable_states();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::types::ServiceState >&
      states() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::types::ServiceState >*
      mutable_states();

  // @@protoc_insertion_point(class_scope:game.bff.ServiceStateMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ServiceStateMap_StatesEntry_DoNotUse,
      std::string, ::game::types::ServiceState,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> states_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bff_2eproto;
};
// -------------------------------------------------------------------

class SimenvConfigMap_ConfigsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SimenvConfigMap_ConfigsEntry_DoNotUse, 
    std::string, ::game::simenv::SimenvConfig,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SimenvConfigMap_ConfigsEntry_DoNotUse, 
    std::string, ::game::simenv::SimenvConfig,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SimenvConfigMap_ConfigsEntry_DoNotUse();
  explicit constexpr SimenvConfigMap_ConfigsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SimenvConfigMap_ConfigsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SimenvConfigMap_ConfigsEntry_DoNotUse& other);
  static const SimenvConfigMap_ConfigsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SimenvConfigMap_ConfigsEntry_DoNotUse*>(&_SimenvConfigMap_ConfigsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "game.bff.SimenvConfigMap.ConfigsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class SimenvConfigMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.bff.SimenvConfigMap) */ {
 public:
  inline SimenvConfigMap() : SimenvConfigMap(nullptr) {}
  ~SimenvConfigMap() override;
  explicit constexpr SimenvConfigMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SimenvConfigMap(const SimenvConfigMap& from);
  SimenvConfigMap(SimenvConfigMap&& from) noexcept
    : SimenvConfigMap() {
    *this = ::std::move(from);
  }

  inline SimenvConfigMap& operator=(const SimenvConfigMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimenvConfigMap& operator=(SimenvConfigMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SimenvConfigMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const SimenvConfigMap* internal_default_instance() {
    return reinterpret_cast<const SimenvConfigMap*>(
               &_SimenvConfigMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SimenvConfigMap& a, SimenvConfigMap& b) {
    a.Swap(&b);
  }
  inline void Swap(SimenvConfigMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimenvConfigMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SimenvConfigMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SimenvConfigMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SimenvConfigMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SimenvConfigMap& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimenvConfigMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.bff.SimenvConfigMap";
  }
  protected:
  explicit SimenvConfigMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kConfigsFieldNumber = 1,
  };
  // map<string, .game.simenv.SimenvConfig> configs = 1;
  int configs_size() const;
  private:
  int _internal_configs_size() const;
  public:
  void clear_configs();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimenvConfig >&
      _internal_configs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimenvConfig >*
      _internal_mutable_configs();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimenvConfig >&
      configs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimenvConfig >*
      mutable_configs();

  // @@protoc_insertion_point(class_scope:game.bff.SimenvConfigMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      SimenvConfigMap_ConfigsEntry_DoNotUse,
      std::string, ::game::simenv::SimenvConfig,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> configs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bff_2eproto;
};
// -------------------------------------------------------------------

class SimCmdMap_CmdsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SimCmdMap_CmdsEntry_DoNotUse, 
    std::string, ::game::simenv::SimCmd,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SimCmdMap_CmdsEntry_DoNotUse, 
    std::string, ::game::simenv::SimCmd,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SimCmdMap_CmdsEntry_DoNotUse();
  explicit constexpr SimCmdMap_CmdsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SimCmdMap_CmdsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SimCmdMap_CmdsEntry_DoNotUse& other);
  static const SimCmdMap_CmdsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SimCmdMap_CmdsEntry_DoNotUse*>(&_SimCmdMap_CmdsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "game.bff.SimCmdMap.CmdsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class SimCmdMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.bff.SimCmdMap) */ {
 public:
  inline SimCmdMap() : SimCmdMap(nullptr) {}
  ~SimCmdMap() override;
  explicit constexpr SimCmdMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SimCmdMap(const SimCmdMap& from);
  SimCmdMap(SimCmdMap&& from) noexcept
    : SimCmdMap() {
    *this = ::std::move(from);
  }

  inline SimCmdMap& operator=(const SimCmdMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimCmdMap& operator=(SimCmdMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SimCmdMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const SimCmdMap* internal_default_instance() {
    return reinterpret_cast<const SimCmdMap*>(
               &_SimCmdMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SimCmdMap& a, SimCmdMap& b) {
    a.Swap(&b);
  }
  inline void Swap(SimCmdMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimCmdMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SimCmdMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SimCmdMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SimCmdMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SimCmdMap& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimCmdMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.bff.SimCmdMap";
  }
  protected:
  explicit SimCmdMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kCmdsFieldNumber = 1,
  };
  // map<string, .game.simenv.SimCmd> cmds = 1;
  int cmds_size() const;
  private:
  int _internal_cmds_size() const;
  public:
  void clear_cmds();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimCmd >&
      _internal_cmds() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimCmd >*
      _internal_mutable_cmds();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimCmd >&
      cmds() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimCmd >*
      mutable_cmds();

  // @@protoc_insertion_point(class_scope:game.bff.SimCmdMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      SimCmdMap_CmdsEntry_DoNotUse,
      std::string, ::game::simenv::SimCmd,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> cmds_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bff_2eproto;
};
// -------------------------------------------------------------------

class SimInfoMap_InfosEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SimInfoMap_InfosEntry_DoNotUse, 
    std::string, ::game::simenv::SimInfo,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SimInfoMap_InfosEntry_DoNotUse, 
    std::string, ::game::simenv::SimInfo,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  SimInfoMap_InfosEntry_DoNotUse();
  explicit constexpr SimInfoMap_InfosEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SimInfoMap_InfosEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SimInfoMap_InfosEntry_DoNotUse& other);
  static const SimInfoMap_InfosEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SimInfoMap_InfosEntry_DoNotUse*>(&_SimInfoMap_InfosEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "game.bff.SimInfoMap.InfosEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class SimInfoMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.bff.SimInfoMap) */ {
 public:
  inline SimInfoMap() : SimInfoMap(nullptr) {}
  ~SimInfoMap() override;
  explicit constexpr SimInfoMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SimInfoMap(const SimInfoMap& from);
  SimInfoMap(SimInfoMap&& from) noexcept
    : SimInfoMap() {
    *this = ::std::move(from);
  }

  inline SimInfoMap& operator=(const SimInfoMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimInfoMap& operator=(SimInfoMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SimInfoMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const SimInfoMap* internal_default_instance() {
    return reinterpret_cast<const SimInfoMap*>(
               &_SimInfoMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SimInfoMap& a, SimInfoMap& b) {
    a.Swap(&b);
  }
  inline void Swap(SimInfoMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimInfoMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SimInfoMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SimInfoMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SimInfoMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SimInfoMap& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimInfoMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.bff.SimInfoMap";
  }
  protected:
  explicit SimInfoMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kInfosFieldNumber = 1,
  };
  // map<string, .game.simenv.SimInfo> infos = 1;
  int infos_size() const;
  private:
  int _internal_infos_size() const;
  public:
  void clear_infos();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimInfo >&
      _internal_infos() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimInfo >*
      _internal_mutable_infos();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimInfo >&
      infos() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimInfo >*
      mutable_infos();

  // @@protoc_insertion_point(class_scope:game.bff.SimInfoMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      SimInfoMap_InfosEntry_DoNotUse,
      std::string, ::game::simenv::SimInfo,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> infos_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bff_2eproto;
};
// -------------------------------------------------------------------

class AgentConfigMap_ConfigsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AgentConfigMap_ConfigsEntry_DoNotUse, 
    std::string, ::game::agent::AgentConfig,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AgentConfigMap_ConfigsEntry_DoNotUse, 
    std::string, ::game::agent::AgentConfig,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  AgentConfigMap_ConfigsEntry_DoNotUse();
  explicit constexpr AgentConfigMap_ConfigsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit AgentConfigMap_ConfigsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AgentConfigMap_ConfigsEntry_DoNotUse& other);
  static const AgentConfigMap_ConfigsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AgentConfigMap_ConfigsEntry_DoNotUse*>(&_AgentConfigMap_ConfigsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "game.bff.AgentConfigMap.ConfigsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class AgentConfigMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.bff.AgentConfigMap) */ {
 public:
  inline AgentConfigMap() : AgentConfigMap(nullptr) {}
  ~AgentConfigMap() override;
  explicit constexpr AgentConfigMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgentConfigMap(const AgentConfigMap& from);
  AgentConfigMap(AgentConfigMap&& from) noexcept
    : AgentConfigMap() {
    *this = ::std::move(from);
  }

  inline AgentConfigMap& operator=(const AgentConfigMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentConfigMap& operator=(AgentConfigMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentConfigMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentConfigMap* internal_default_instance() {
    return reinterpret_cast<const AgentConfigMap*>(
               &_AgentConfigMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AgentConfigMap& a, AgentConfigMap& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentConfigMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentConfigMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgentConfigMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AgentConfigMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AgentConfigMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AgentConfigMap& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentConfigMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.bff.AgentConfigMap";
  }
  protected:
  explicit AgentConfigMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kConfigsFieldNumber = 1,
  };
  // map<string, .game.agent.AgentConfig> configs = 1;
  int configs_size() const;
  private:
  int _internal_configs_size() const;
  public:
  void clear_configs();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::AgentConfig >&
      _internal_configs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::AgentConfig >*
      _internal_mutable_configs();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::AgentConfig >&
      configs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::AgentConfig >*
      mutable_configs();

  // @@protoc_insertion_point(class_scope:game.bff.AgentConfigMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      AgentConfigMap_ConfigsEntry_DoNotUse,
      std::string, ::game::agent::AgentConfig,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> configs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bff_2eproto;
};
// -------------------------------------------------------------------

class AgentModeMap_ModesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AgentModeMap_ModesEntry_DoNotUse, 
    std::string, ::game::agent::AgentMode,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AgentModeMap_ModesEntry_DoNotUse, 
    std::string, ::game::agent::AgentMode,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  AgentModeMap_ModesEntry_DoNotUse();
  explicit constexpr AgentModeMap_ModesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit AgentModeMap_ModesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AgentModeMap_ModesEntry_DoNotUse& other);
  static const AgentModeMap_ModesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AgentModeMap_ModesEntry_DoNotUse*>(&_AgentModeMap_ModesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "game.bff.AgentModeMap.ModesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class AgentModeMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.bff.AgentModeMap) */ {
 public:
  inline AgentModeMap() : AgentModeMap(nullptr) {}
  ~AgentModeMap() override;
  explicit constexpr AgentModeMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgentModeMap(const AgentModeMap& from);
  AgentModeMap(AgentModeMap&& from) noexcept
    : AgentModeMap() {
    *this = ::std::move(from);
  }

  inline AgentModeMap& operator=(const AgentModeMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentModeMap& operator=(AgentModeMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentModeMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentModeMap* internal_default_instance() {
    return reinterpret_cast<const AgentModeMap*>(
               &_AgentModeMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(AgentModeMap& a, AgentModeMap& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentModeMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentModeMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgentModeMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AgentModeMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AgentModeMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AgentModeMap& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentModeMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.bff.AgentModeMap";
  }
  protected:
  explicit AgentModeMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kModesFieldNumber = 1,
  };
  // map<string, .game.agent.AgentMode> modes = 1;
  int modes_size() const;
  private:
  int _internal_modes_size() const;
  public:
  void clear_modes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::AgentMode >&
      _internal_modes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::AgentMode >*
      _internal_mutable_modes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::AgentMode >&
      modes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::AgentMode >*
      mutable_modes();

  // @@protoc_insertion_point(class_scope:game.bff.AgentModeMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      AgentModeMap_ModesEntry_DoNotUse,
      std::string, ::game::agent::AgentMode,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> modes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bff_2eproto;
};
// -------------------------------------------------------------------

class ModelWeightsMap_WeightsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelWeightsMap_WeightsEntry_DoNotUse, 
    std::string, ::game::agent::ModelWeights,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelWeightsMap_WeightsEntry_DoNotUse, 
    std::string, ::game::agent::ModelWeights,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ModelWeightsMap_WeightsEntry_DoNotUse();
  explicit constexpr ModelWeightsMap_WeightsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ModelWeightsMap_WeightsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelWeightsMap_WeightsEntry_DoNotUse& other);
  static const ModelWeightsMap_WeightsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelWeightsMap_WeightsEntry_DoNotUse*>(&_ModelWeightsMap_WeightsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "game.bff.ModelWeightsMap.WeightsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class ModelWeightsMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.bff.ModelWeightsMap) */ {
 public:
  inline ModelWeightsMap() : ModelWeightsMap(nullptr) {}
  ~ModelWeightsMap() override;
  explicit constexpr ModelWeightsMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelWeightsMap(const ModelWeightsMap& from);
  ModelWeightsMap(ModelWeightsMap&& from) noexcept
    : ModelWeightsMap() {
    *this = ::std::move(from);
  }

  inline ModelWeightsMap& operator=(const ModelWeightsMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelWeightsMap& operator=(ModelWeightsMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelWeightsMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelWeightsMap* internal_default_instance() {
    return reinterpret_cast<const ModelWeightsMap*>(
               &_ModelWeightsMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ModelWeightsMap& a, ModelWeightsMap& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelWeightsMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelWeightsMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelWeightsMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelWeightsMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelWeightsMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ModelWeightsMap& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelWeightsMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.bff.ModelWeightsMap";
  }
  protected:
  explicit ModelWeightsMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kWeightsFieldNumber = 1,
  };
  // map<string, .game.agent.ModelWeights> weights = 1;
  int weights_size() const;
  private:
  int _internal_weights_size() const;
  public:
  void clear_weights();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelWeights >&
      _internal_weights() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelWeights >*
      _internal_mutable_weights();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelWeights >&
      weights() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelWeights >*
      mutable_weights();

  // @@protoc_insertion_point(class_scope:game.bff.ModelWeightsMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ModelWeightsMap_WeightsEntry_DoNotUse,
      std::string, ::game::agent::ModelWeights,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> weights_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bff_2eproto;
};
// -------------------------------------------------------------------

class ModelBufferMap_BuffersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelBufferMap_BuffersEntry_DoNotUse, 
    std::string, ::game::agent::ModelBuffer,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelBufferMap_BuffersEntry_DoNotUse, 
    std::string, ::game::agent::ModelBuffer,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ModelBufferMap_BuffersEntry_DoNotUse();
  explicit constexpr ModelBufferMap_BuffersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ModelBufferMap_BuffersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelBufferMap_BuffersEntry_DoNotUse& other);
  static const ModelBufferMap_BuffersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelBufferMap_BuffersEntry_DoNotUse*>(&_ModelBufferMap_BuffersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "game.bff.ModelBufferMap.BuffersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class ModelBufferMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.bff.ModelBufferMap) */ {
 public:
  inline ModelBufferMap() : ModelBufferMap(nullptr) {}
  ~ModelBufferMap() override;
  explicit constexpr ModelBufferMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelBufferMap(const ModelBufferMap& from);
  ModelBufferMap(ModelBufferMap&& from) noexcept
    : ModelBufferMap() {
    *this = ::std::move(from);
  }

  inline ModelBufferMap& operator=(const ModelBufferMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelBufferMap& operator=(ModelBufferMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelBufferMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelBufferMap* internal_default_instance() {
    return reinterpret_cast<const ModelBufferMap*>(
               &_ModelBufferMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ModelBufferMap& a, ModelBufferMap& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelBufferMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelBufferMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelBufferMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelBufferMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelBufferMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ModelBufferMap& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelBufferMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.bff.ModelBufferMap";
  }
  protected:
  explicit ModelBufferMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kBuffersFieldNumber = 1,
  };
  // map<string, .game.agent.ModelBuffer> buffers = 1;
  int buffers_size() const;
  private:
  int _internal_buffers_size() const;
  public:
  void clear_buffers();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelBuffer >&
      _internal_buffers() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelBuffer >*
      _internal_mutable_buffers();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelBuffer >&
      buffers() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelBuffer >*
      mutable_buffers();

  // @@protoc_insertion_point(class_scope:game.bff.ModelBufferMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ModelBufferMap_BuffersEntry_DoNotUse,
      std::string, ::game::agent::ModelBuffer,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> buffers_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bff_2eproto;
};
// -------------------------------------------------------------------

class ModelStatusMap_StatusEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelStatusMap_StatusEntry_DoNotUse, 
    std::string, ::game::agent::ModelStatus,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelStatusMap_StatusEntry_DoNotUse, 
    std::string, ::game::agent::ModelStatus,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ModelStatusMap_StatusEntry_DoNotUse();
  explicit constexpr ModelStatusMap_StatusEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ModelStatusMap_StatusEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelStatusMap_StatusEntry_DoNotUse& other);
  static const ModelStatusMap_StatusEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelStatusMap_StatusEntry_DoNotUse*>(&_ModelStatusMap_StatusEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "game.bff.ModelStatusMap.StatusEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class ModelStatusMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.bff.ModelStatusMap) */ {
 public:
  inline ModelStatusMap() : ModelStatusMap(nullptr) {}
  ~ModelStatusMap() override;
  explicit constexpr ModelStatusMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelStatusMap(const ModelStatusMap& from);
  ModelStatusMap(ModelStatusMap&& from) noexcept
    : ModelStatusMap() {
    *this = ::std::move(from);
  }

  inline ModelStatusMap& operator=(const ModelStatusMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelStatusMap& operator=(ModelStatusMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelStatusMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelStatusMap* internal_default_instance() {
    return reinterpret_cast<const ModelStatusMap*>(
               &_ModelStatusMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ModelStatusMap& a, ModelStatusMap& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelStatusMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelStatusMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelStatusMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelStatusMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelStatusMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ModelStatusMap& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelStatusMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.bff.ModelStatusMap";
  }
  protected:
  explicit ModelStatusMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // map<string, .game.agent.ModelStatus> status = 1;
  int status_size() const;
  private:
  int _internal_status_size() const;
  public:
  void clear_status();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelStatus >&
      _internal_status() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelStatus >*
      _internal_mutable_status();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelStatus >&
      status() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelStatus >*
      mutable_status();

  // @@protoc_insertion_point(class_scope:game.bff.ModelStatusMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ModelStatusMap_StatusEntry_DoNotUse,
      std::string, ::game::agent::ModelStatus,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bff_2eproto;
};
// -------------------------------------------------------------------

class CallDataMap_DataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CallDataMap_DataEntry_DoNotUse, 
    std::string, ::game::types::CallData,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CallDataMap_DataEntry_DoNotUse, 
    std::string, ::game::types::CallData,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  CallDataMap_DataEntry_DoNotUse();
  explicit constexpr CallDataMap_DataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CallDataMap_DataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CallDataMap_DataEntry_DoNotUse& other);
  static const CallDataMap_DataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CallDataMap_DataEntry_DoNotUse*>(&_CallDataMap_DataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "game.bff.CallDataMap.DataEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class CallDataMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.bff.CallDataMap) */ {
 public:
  inline CallDataMap() : CallDataMap(nullptr) {}
  ~CallDataMap() override;
  explicit constexpr CallDataMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallDataMap(const CallDataMap& from);
  CallDataMap(CallDataMap&& from) noexcept
    : CallDataMap() {
    *this = ::std::move(from);
  }

  inline CallDataMap& operator=(const CallDataMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallDataMap& operator=(CallDataMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallDataMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallDataMap* internal_default_instance() {
    return reinterpret_cast<const CallDataMap*>(
               &_CallDataMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(CallDataMap& a, CallDataMap& b) {
    a.Swap(&b);
  }
  inline void Swap(CallDataMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallDataMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallDataMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallDataMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CallDataMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CallDataMap& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CallDataMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.bff.CallDataMap";
  }
  protected:
  explicit CallDataMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // map<string, .game.types.CallData> data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::types::CallData >&
      _internal_data() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::types::CallData >*
      _internal_mutable_data();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::types::CallData >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::types::CallData >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:game.bff.CallDataMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      CallDataMap_DataEntry_DoNotUse,
      std::string, ::game::types::CallData,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bff_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ServiceInfo

// string type = 1;
inline void ServiceInfo::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& ServiceInfo::type() const {
  // @@protoc_insertion_point(field_get:game.bff.ServiceInfo.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceInfo::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.bff.ServiceInfo.type)
}
inline std::string* ServiceInfo::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:game.bff.ServiceInfo.type)
  return _s;
}
inline const std::string& ServiceInfo::_internal_type() const {
  return type_.Get();
}
inline void ServiceInfo::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServiceInfo::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServiceInfo::release_type() {
  // @@protoc_insertion_point(field_release:game.bff.ServiceInfo.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServiceInfo::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.bff.ServiceInfo.type)
}

// string name = 2;
inline void ServiceInfo::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ServiceInfo::name() const {
  // @@protoc_insertion_point(field_get:game.bff.ServiceInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.bff.ServiceInfo.name)
}
inline std::string* ServiceInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:game.bff.ServiceInfo.name)
  return _s;
}
inline const std::string& ServiceInfo::_internal_name() const {
  return name_.Get();
}
inline void ServiceInfo::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServiceInfo::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServiceInfo::release_name() {
  // @@protoc_insertion_point(field_release:game.bff.ServiceInfo.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServiceInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.bff.ServiceInfo.name)
}

// string host = 3;
inline void ServiceInfo::clear_host() {
  host_.ClearToEmpty();
}
inline const std::string& ServiceInfo::host() const {
  // @@protoc_insertion_point(field_get:game.bff.ServiceInfo.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceInfo::set_host(ArgT0&& arg0, ArgT... args) {
 
 host_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.bff.ServiceInfo.host)
}
inline std::string* ServiceInfo::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:game.bff.ServiceInfo.host)
  return _s;
}
inline const std::string& ServiceInfo::_internal_host() const {
  return host_.Get();
}
inline void ServiceInfo::_internal_set_host(const std::string& value) {
  
  host_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServiceInfo::_internal_mutable_host() {
  
  return host_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServiceInfo::release_host() {
  // @@protoc_insertion_point(field_release:game.bff.ServiceInfo.host)
  return host_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServiceInfo::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  host_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (host_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.bff.ServiceInfo.host)
}

// uint32 port = 4;
inline void ServiceInfo::clear_port() {
  port_ = 0u;
}
inline uint32_t ServiceInfo::_internal_port() const {
  return port_;
}
inline uint32_t ServiceInfo::port() const {
  // @@protoc_insertion_point(field_get:game.bff.ServiceInfo.port)
  return _internal_port();
}
inline void ServiceInfo::_internal_set_port(uint32_t value) {
  
  port_ = value;
}
inline void ServiceInfo::set_port(uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:game.bff.ServiceInfo.port)
}

// string desc = 5;
inline void ServiceInfo::clear_desc() {
  desc_.ClearToEmpty();
}
inline const std::string& ServiceInfo::desc() const {
  // @@protoc_insertion_point(field_get:game.bff.ServiceInfo.desc)
  return _internal_desc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceInfo::set_desc(ArgT0&& arg0, ArgT... args) {
 
 desc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:game.bff.ServiceInfo.desc)
}
inline std::string* ServiceInfo::mutable_desc() {
  std::string* _s = _internal_mutable_desc();
  // @@protoc_insertion_point(field_mutable:game.bff.ServiceInfo.desc)
  return _s;
}
inline const std::string& ServiceInfo::_internal_desc() const {
  return desc_.Get();
}
inline void ServiceInfo::_internal_set_desc(const std::string& value) {
  
  desc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServiceInfo::_internal_mutable_desc() {
  
  return desc_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServiceInfo::release_desc() {
  // @@protoc_insertion_point(field_release:game.bff.ServiceInfo.desc)
  return desc_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServiceInfo::set_allocated_desc(std::string* desc) {
  if (desc != nullptr) {
    
  } else {
    
  }
  desc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), desc,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (desc_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    desc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.bff.ServiceInfo.desc)
}

// -------------------------------------------------------------------

// ServiceIdList

// repeated string ids = 1;
inline int ServiceIdList::_internal_ids_size() const {
  return ids_.size();
}
inline int ServiceIdList::ids_size() const {
  return _internal_ids_size();
}
inline void ServiceIdList::clear_ids() {
  ids_.Clear();
}
inline std::string* ServiceIdList::add_ids() {
  std::string* _s = _internal_add_ids();
  // @@protoc_insertion_point(field_add_mutable:game.bff.ServiceIdList.ids)
  return _s;
}
inline const std::string& ServiceIdList::_internal_ids(int index) const {
  return ids_.Get(index);
}
inline const std::string& ServiceIdList::ids(int index) const {
  // @@protoc_insertion_point(field_get:game.bff.ServiceIdList.ids)
  return _internal_ids(index);
}
inline std::string* ServiceIdList::mutable_ids(int index) {
  // @@protoc_insertion_point(field_mutable:game.bff.ServiceIdList.ids)
  return ids_.Mutable(index);
}
inline void ServiceIdList::set_ids(int index, const std::string& value) {
  ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:game.bff.ServiceIdList.ids)
}
inline void ServiceIdList::set_ids(int index, std::string&& value) {
  ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:game.bff.ServiceIdList.ids)
}
inline void ServiceIdList::set_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:game.bff.ServiceIdList.ids)
}
inline void ServiceIdList::set_ids(int index, const char* value, size_t size) {
  ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:game.bff.ServiceIdList.ids)
}
inline std::string* ServiceIdList::_internal_add_ids() {
  return ids_.Add();
}
inline void ServiceIdList::add_ids(const std::string& value) {
  ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:game.bff.ServiceIdList.ids)
}
inline void ServiceIdList::add_ids(std::string&& value) {
  ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:game.bff.ServiceIdList.ids)
}
inline void ServiceIdList::add_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:game.bff.ServiceIdList.ids)
}
inline void ServiceIdList::add_ids(const char* value, size_t size) {
  ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:game.bff.ServiceIdList.ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ServiceIdList::ids() const {
  // @@protoc_insertion_point(field_list:game.bff.ServiceIdList.ids)
  return ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ServiceIdList::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:game.bff.ServiceIdList.ids)
  return &ids_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ServiceInfoMap

// map<string, .game.bff.ServiceInfo> services = 1;
inline int ServiceInfoMap::_internal_services_size() const {
  return services_.size();
}
inline int ServiceInfoMap::services_size() const {
  return _internal_services_size();
}
inline void ServiceInfoMap::clear_services() {
  services_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::bff::ServiceInfo >&
ServiceInfoMap::_internal_services() const {
  return services_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::bff::ServiceInfo >&
ServiceInfoMap::services() const {
  // @@protoc_insertion_point(field_map:game.bff.ServiceInfoMap.services)
  return _internal_services();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::bff::ServiceInfo >*
ServiceInfoMap::_internal_mutable_services() {
  return services_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::bff::ServiceInfo >*
ServiceInfoMap::mutable_services() {
  // @@protoc_insertion_point(field_mutable_map:game.bff.ServiceInfoMap.services)
  return _internal_mutable_services();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ServiceStateMap

// map<string, .game.types.ServiceState> states = 1;
inline int ServiceStateMap::_internal_states_size() const {
  return states_.size();
}
inline int ServiceStateMap::states_size() const {
  return _internal_states_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::types::ServiceState >&
ServiceStateMap::_internal_states() const {
  return states_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::types::ServiceState >&
ServiceStateMap::states() const {
  // @@protoc_insertion_point(field_map:game.bff.ServiceStateMap.states)
  return _internal_states();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::types::ServiceState >*
ServiceStateMap::_internal_mutable_states() {
  return states_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::types::ServiceState >*
ServiceStateMap::mutable_states() {
  // @@protoc_insertion_point(field_mutable_map:game.bff.ServiceStateMap.states)
  return _internal_mutable_states();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SimenvConfigMap

// map<string, .game.simenv.SimenvConfig> configs = 1;
inline int SimenvConfigMap::_internal_configs_size() const {
  return configs_.size();
}
inline int SimenvConfigMap::configs_size() const {
  return _internal_configs_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimenvConfig >&
SimenvConfigMap::_internal_configs() const {
  return configs_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimenvConfig >&
SimenvConfigMap::configs() const {
  // @@protoc_insertion_point(field_map:game.bff.SimenvConfigMap.configs)
  return _internal_configs();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimenvConfig >*
SimenvConfigMap::_internal_mutable_configs() {
  return configs_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimenvConfig >*
SimenvConfigMap::mutable_configs() {
  // @@protoc_insertion_point(field_mutable_map:game.bff.SimenvConfigMap.configs)
  return _internal_mutable_configs();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SimCmdMap

// map<string, .game.simenv.SimCmd> cmds = 1;
inline int SimCmdMap::_internal_cmds_size() const {
  return cmds_.size();
}
inline int SimCmdMap::cmds_size() const {
  return _internal_cmds_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimCmd >&
SimCmdMap::_internal_cmds() const {
  return cmds_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimCmd >&
SimCmdMap::cmds() const {
  // @@protoc_insertion_point(field_map:game.bff.SimCmdMap.cmds)
  return _internal_cmds();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimCmd >*
SimCmdMap::_internal_mutable_cmds() {
  return cmds_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimCmd >*
SimCmdMap::mutable_cmds() {
  // @@protoc_insertion_point(field_mutable_map:game.bff.SimCmdMap.cmds)
  return _internal_mutable_cmds();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SimInfoMap

// map<string, .game.simenv.SimInfo> infos = 1;
inline int SimInfoMap::_internal_infos_size() const {
  return infos_.size();
}
inline int SimInfoMap::infos_size() const {
  return _internal_infos_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimInfo >&
SimInfoMap::_internal_infos() const {
  return infos_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimInfo >&
SimInfoMap::infos() const {
  // @@protoc_insertion_point(field_map:game.bff.SimInfoMap.infos)
  return _internal_infos();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimInfo >*
SimInfoMap::_internal_mutable_infos() {
  return infos_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimInfo >*
SimInfoMap::mutable_infos() {
  // @@protoc_insertion_point(field_mutable_map:game.bff.SimInfoMap.infos)
  return _internal_mutable_infos();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AgentConfigMap

// map<string, .game.agent.AgentConfig> configs = 1;
inline int AgentConfigMap::_internal_configs_size() const {
  return configs_.size();
}
inline int AgentConfigMap::configs_size() const {
  return _internal_configs_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::AgentConfig >&
AgentConfigMap::_internal_configs() const {
  return configs_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::AgentConfig >&
AgentConfigMap::configs() const {
  // @@protoc_insertion_point(field_map:game.bff.AgentConfigMap.configs)
  return _internal_configs();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::AgentConfig >*
AgentConfigMap::_internal_mutable_configs() {
  return configs_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::AgentConfig >*
AgentConfigMap::mutable_configs() {
  // @@protoc_insertion_point(field_mutable_map:game.bff.AgentConfigMap.configs)
  return _internal_mutable_configs();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AgentModeMap

// map<string, .game.agent.AgentMode> modes = 1;
inline int AgentModeMap::_internal_modes_size() const {
  return modes_.size();
}
inline int AgentModeMap::modes_size() const {
  return _internal_modes_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::AgentMode >&
AgentModeMap::_internal_modes() const {
  return modes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::AgentMode >&
AgentModeMap::modes() const {
  // @@protoc_insertion_point(field_map:game.bff.AgentModeMap.modes)
  return _internal_modes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::AgentMode >*
AgentModeMap::_internal_mutable_modes() {
  return modes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::AgentMode >*
AgentModeMap::mutable_modes() {
  // @@protoc_insertion_point(field_mutable_map:game.bff.AgentModeMap.modes)
  return _internal_mutable_modes();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelWeightsMap

// map<string, .game.agent.ModelWeights> weights = 1;
inline int ModelWeightsMap::_internal_weights_size() const {
  return weights_.size();
}
inline int ModelWeightsMap::weights_size() const {
  return _internal_weights_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelWeights >&
ModelWeightsMap::_internal_weights() const {
  return weights_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelWeights >&
ModelWeightsMap::weights() const {
  // @@protoc_insertion_point(field_map:game.bff.ModelWeightsMap.weights)
  return _internal_weights();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelWeights >*
ModelWeightsMap::_internal_mutable_weights() {
  return weights_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelWeights >*
ModelWeightsMap::mutable_weights() {
  // @@protoc_insertion_point(field_mutable_map:game.bff.ModelWeightsMap.weights)
  return _internal_mutable_weights();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelBufferMap

// map<string, .game.agent.ModelBuffer> buffers = 1;
inline int ModelBufferMap::_internal_buffers_size() const {
  return buffers_.size();
}
inline int ModelBufferMap::buffers_size() const {
  return _internal_buffers_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelBuffer >&
ModelBufferMap::_internal_buffers() const {
  return buffers_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelBuffer >&
ModelBufferMap::buffers() const {
  // @@protoc_insertion_point(field_map:game.bff.ModelBufferMap.buffers)
  return _internal_buffers();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelBuffer >*
ModelBufferMap::_internal_mutable_buffers() {
  return buffers_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelBuffer >*
ModelBufferMap::mutable_buffers() {
  // @@protoc_insertion_point(field_mutable_map:game.bff.ModelBufferMap.buffers)
  return _internal_mutable_buffers();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelStatusMap

// map<string, .game.agent.ModelStatus> status = 1;
inline int ModelStatusMap::_internal_status_size() const {
  return status_.size();
}
inline int ModelStatusMap::status_size() const {
  return _internal_status_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelStatus >&
ModelStatusMap::_internal_status() const {
  return status_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelStatus >&
ModelStatusMap::status() const {
  // @@protoc_insertion_point(field_map:game.bff.ModelStatusMap.status)
  return _internal_status();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelStatus >*
ModelStatusMap::_internal_mutable_status() {
  return status_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelStatus >*
ModelStatusMap::mutable_status() {
  // @@protoc_insertion_point(field_mutable_map:game.bff.ModelStatusMap.status)
  return _internal_mutable_status();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CallDataMap

// map<string, .game.types.CallData> data = 1;
inline int CallDataMap::_internal_data_size() const {
  return data_.size();
}
inline int CallDataMap::data_size() const {
  return _internal_data_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::types::CallData >&
CallDataMap::_internal_data() const {
  return data_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::types::CallData >&
CallDataMap::data() const {
  // @@protoc_insertion_point(field_map:game.bff.CallDataMap.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::types::CallData >*
CallDataMap::_internal_mutable_data() {
  return data_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::types::CallData >*
CallDataMap::mutable_data() {
  // @@protoc_insertion_point(field_mutable_map:game.bff.CallDataMap.data)
  return _internal_mutable_data();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace bff
}  // namespace game

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bff_2eproto
