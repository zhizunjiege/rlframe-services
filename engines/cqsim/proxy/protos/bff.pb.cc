// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bff.proto

#include "bff.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace game {
namespace bff {
constexpr ServiceInfo::ServiceInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : type_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , host_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , desc_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , port_(0u){}
struct ServiceInfoDefaultTypeInternal {
  constexpr ServiceInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ServiceInfoDefaultTypeInternal() {}
  union {
    ServiceInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ServiceInfoDefaultTypeInternal _ServiceInfo_default_instance_;
constexpr ServiceIdList::ServiceIdList(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ids_(){}
struct ServiceIdListDefaultTypeInternal {
  constexpr ServiceIdListDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ServiceIdListDefaultTypeInternal() {}
  union {
    ServiceIdList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ServiceIdListDefaultTypeInternal _ServiceIdList_default_instance_;
constexpr ServiceInfoMap_ServicesEntry_DoNotUse::ServiceInfoMap_ServicesEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ServiceInfoMap_ServicesEntry_DoNotUseDefaultTypeInternal {
  constexpr ServiceInfoMap_ServicesEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ServiceInfoMap_ServicesEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ServiceInfoMap_ServicesEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ServiceInfoMap_ServicesEntry_DoNotUseDefaultTypeInternal _ServiceInfoMap_ServicesEntry_DoNotUse_default_instance_;
constexpr ServiceInfoMap::ServiceInfoMap(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : services_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}){}
struct ServiceInfoMapDefaultTypeInternal {
  constexpr ServiceInfoMapDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ServiceInfoMapDefaultTypeInternal() {}
  union {
    ServiceInfoMap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ServiceInfoMapDefaultTypeInternal _ServiceInfoMap_default_instance_;
constexpr ServiceStateMap_StatesEntry_DoNotUse::ServiceStateMap_StatesEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ServiceStateMap_StatesEntry_DoNotUseDefaultTypeInternal {
  constexpr ServiceStateMap_StatesEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ServiceStateMap_StatesEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ServiceStateMap_StatesEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ServiceStateMap_StatesEntry_DoNotUseDefaultTypeInternal _ServiceStateMap_StatesEntry_DoNotUse_default_instance_;
constexpr ServiceStateMap::ServiceStateMap(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : states_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}){}
struct ServiceStateMapDefaultTypeInternal {
  constexpr ServiceStateMapDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ServiceStateMapDefaultTypeInternal() {}
  union {
    ServiceStateMap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ServiceStateMapDefaultTypeInternal _ServiceStateMap_default_instance_;
constexpr SimenvConfigMap_ConfigsEntry_DoNotUse::SimenvConfigMap_ConfigsEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct SimenvConfigMap_ConfigsEntry_DoNotUseDefaultTypeInternal {
  constexpr SimenvConfigMap_ConfigsEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SimenvConfigMap_ConfigsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    SimenvConfigMap_ConfigsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SimenvConfigMap_ConfigsEntry_DoNotUseDefaultTypeInternal _SimenvConfigMap_ConfigsEntry_DoNotUse_default_instance_;
constexpr SimenvConfigMap::SimenvConfigMap(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : configs_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}){}
struct SimenvConfigMapDefaultTypeInternal {
  constexpr SimenvConfigMapDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SimenvConfigMapDefaultTypeInternal() {}
  union {
    SimenvConfigMap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SimenvConfigMapDefaultTypeInternal _SimenvConfigMap_default_instance_;
constexpr SimCmdMap_CmdsEntry_DoNotUse::SimCmdMap_CmdsEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct SimCmdMap_CmdsEntry_DoNotUseDefaultTypeInternal {
  constexpr SimCmdMap_CmdsEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SimCmdMap_CmdsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    SimCmdMap_CmdsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SimCmdMap_CmdsEntry_DoNotUseDefaultTypeInternal _SimCmdMap_CmdsEntry_DoNotUse_default_instance_;
constexpr SimCmdMap::SimCmdMap(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : cmds_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}){}
struct SimCmdMapDefaultTypeInternal {
  constexpr SimCmdMapDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SimCmdMapDefaultTypeInternal() {}
  union {
    SimCmdMap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SimCmdMapDefaultTypeInternal _SimCmdMap_default_instance_;
constexpr SimInfoMap_InfosEntry_DoNotUse::SimInfoMap_InfosEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct SimInfoMap_InfosEntry_DoNotUseDefaultTypeInternal {
  constexpr SimInfoMap_InfosEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SimInfoMap_InfosEntry_DoNotUseDefaultTypeInternal() {}
  union {
    SimInfoMap_InfosEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SimInfoMap_InfosEntry_DoNotUseDefaultTypeInternal _SimInfoMap_InfosEntry_DoNotUse_default_instance_;
constexpr SimInfoMap::SimInfoMap(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : infos_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}){}
struct SimInfoMapDefaultTypeInternal {
  constexpr SimInfoMapDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SimInfoMapDefaultTypeInternal() {}
  union {
    SimInfoMap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SimInfoMapDefaultTypeInternal _SimInfoMap_default_instance_;
constexpr AgentConfigMap_ConfigsEntry_DoNotUse::AgentConfigMap_ConfigsEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct AgentConfigMap_ConfigsEntry_DoNotUseDefaultTypeInternal {
  constexpr AgentConfigMap_ConfigsEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AgentConfigMap_ConfigsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    AgentConfigMap_ConfigsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AgentConfigMap_ConfigsEntry_DoNotUseDefaultTypeInternal _AgentConfigMap_ConfigsEntry_DoNotUse_default_instance_;
constexpr AgentConfigMap::AgentConfigMap(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : configs_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}){}
struct AgentConfigMapDefaultTypeInternal {
  constexpr AgentConfigMapDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AgentConfigMapDefaultTypeInternal() {}
  union {
    AgentConfigMap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AgentConfigMapDefaultTypeInternal _AgentConfigMap_default_instance_;
constexpr AgentModeMap_ModesEntry_DoNotUse::AgentModeMap_ModesEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct AgentModeMap_ModesEntry_DoNotUseDefaultTypeInternal {
  constexpr AgentModeMap_ModesEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AgentModeMap_ModesEntry_DoNotUseDefaultTypeInternal() {}
  union {
    AgentModeMap_ModesEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AgentModeMap_ModesEntry_DoNotUseDefaultTypeInternal _AgentModeMap_ModesEntry_DoNotUse_default_instance_;
constexpr AgentModeMap::AgentModeMap(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : modes_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}){}
struct AgentModeMapDefaultTypeInternal {
  constexpr AgentModeMapDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AgentModeMapDefaultTypeInternal() {}
  union {
    AgentModeMap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AgentModeMapDefaultTypeInternal _AgentModeMap_default_instance_;
constexpr ModelWeightsMap_WeightsEntry_DoNotUse::ModelWeightsMap_WeightsEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ModelWeightsMap_WeightsEntry_DoNotUseDefaultTypeInternal {
  constexpr ModelWeightsMap_WeightsEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelWeightsMap_WeightsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ModelWeightsMap_WeightsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelWeightsMap_WeightsEntry_DoNotUseDefaultTypeInternal _ModelWeightsMap_WeightsEntry_DoNotUse_default_instance_;
constexpr ModelWeightsMap::ModelWeightsMap(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : weights_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}){}
struct ModelWeightsMapDefaultTypeInternal {
  constexpr ModelWeightsMapDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelWeightsMapDefaultTypeInternal() {}
  union {
    ModelWeightsMap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelWeightsMapDefaultTypeInternal _ModelWeightsMap_default_instance_;
constexpr ModelBufferMap_BuffersEntry_DoNotUse::ModelBufferMap_BuffersEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ModelBufferMap_BuffersEntry_DoNotUseDefaultTypeInternal {
  constexpr ModelBufferMap_BuffersEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelBufferMap_BuffersEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ModelBufferMap_BuffersEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelBufferMap_BuffersEntry_DoNotUseDefaultTypeInternal _ModelBufferMap_BuffersEntry_DoNotUse_default_instance_;
constexpr ModelBufferMap::ModelBufferMap(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : buffers_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}){}
struct ModelBufferMapDefaultTypeInternal {
  constexpr ModelBufferMapDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelBufferMapDefaultTypeInternal() {}
  union {
    ModelBufferMap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelBufferMapDefaultTypeInternal _ModelBufferMap_default_instance_;
constexpr ModelStatusMap_StatusEntry_DoNotUse::ModelStatusMap_StatusEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct ModelStatusMap_StatusEntry_DoNotUseDefaultTypeInternal {
  constexpr ModelStatusMap_StatusEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelStatusMap_StatusEntry_DoNotUseDefaultTypeInternal() {}
  union {
    ModelStatusMap_StatusEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelStatusMap_StatusEntry_DoNotUseDefaultTypeInternal _ModelStatusMap_StatusEntry_DoNotUse_default_instance_;
constexpr ModelStatusMap::ModelStatusMap(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : status_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}){}
struct ModelStatusMapDefaultTypeInternal {
  constexpr ModelStatusMapDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ModelStatusMapDefaultTypeInternal() {}
  union {
    ModelStatusMap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ModelStatusMapDefaultTypeInternal _ModelStatusMap_default_instance_;
constexpr CallDataMap_DataEntry_DoNotUse::CallDataMap_DataEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CallDataMap_DataEntry_DoNotUseDefaultTypeInternal {
  constexpr CallDataMap_DataEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CallDataMap_DataEntry_DoNotUseDefaultTypeInternal() {}
  union {
    CallDataMap_DataEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CallDataMap_DataEntry_DoNotUseDefaultTypeInternal _CallDataMap_DataEntry_DoNotUse_default_instance_;
constexpr CallDataMap::CallDataMap(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : data_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}){}
struct CallDataMapDefaultTypeInternal {
  constexpr CallDataMapDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CallDataMapDefaultTypeInternal() {}
  union {
    CallDataMap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CallDataMapDefaultTypeInternal _CallDataMap_default_instance_;
}  // namespace bff
}  // namespace game
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_bff_2eproto[24];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_bff_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_bff_2eproto = nullptr;

const uint32_t TableStruct_bff_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::bff::ServiceInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::bff::ServiceInfo, type_),
  PROTOBUF_FIELD_OFFSET(::game::bff::ServiceInfo, name_),
  PROTOBUF_FIELD_OFFSET(::game::bff::ServiceInfo, host_),
  PROTOBUF_FIELD_OFFSET(::game::bff::ServiceInfo, port_),
  PROTOBUF_FIELD_OFFSET(::game::bff::ServiceInfo, desc_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::bff::ServiceIdList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::bff::ServiceIdList, ids_),
  PROTOBUF_FIELD_OFFSET(::game::bff::ServiceInfoMap_ServicesEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::game::bff::ServiceInfoMap_ServicesEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::bff::ServiceInfoMap_ServicesEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::game::bff::ServiceInfoMap_ServicesEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::bff::ServiceInfoMap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::bff::ServiceInfoMap, services_),
  PROTOBUF_FIELD_OFFSET(::game::bff::ServiceStateMap_StatesEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::game::bff::ServiceStateMap_StatesEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::bff::ServiceStateMap_StatesEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::game::bff::ServiceStateMap_StatesEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::bff::ServiceStateMap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::bff::ServiceStateMap, states_),
  PROTOBUF_FIELD_OFFSET(::game::bff::SimenvConfigMap_ConfigsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::game::bff::SimenvConfigMap_ConfigsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::bff::SimenvConfigMap_ConfigsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::game::bff::SimenvConfigMap_ConfigsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::bff::SimenvConfigMap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::bff::SimenvConfigMap, configs_),
  PROTOBUF_FIELD_OFFSET(::game::bff::SimCmdMap_CmdsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::game::bff::SimCmdMap_CmdsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::bff::SimCmdMap_CmdsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::game::bff::SimCmdMap_CmdsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::bff::SimCmdMap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::bff::SimCmdMap, cmds_),
  PROTOBUF_FIELD_OFFSET(::game::bff::SimInfoMap_InfosEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::game::bff::SimInfoMap_InfosEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::bff::SimInfoMap_InfosEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::game::bff::SimInfoMap_InfosEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::bff::SimInfoMap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::bff::SimInfoMap, infos_),
  PROTOBUF_FIELD_OFFSET(::game::bff::AgentConfigMap_ConfigsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::game::bff::AgentConfigMap_ConfigsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::bff::AgentConfigMap_ConfigsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::game::bff::AgentConfigMap_ConfigsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::bff::AgentConfigMap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::bff::AgentConfigMap, configs_),
  PROTOBUF_FIELD_OFFSET(::game::bff::AgentModeMap_ModesEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::game::bff::AgentModeMap_ModesEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::bff::AgentModeMap_ModesEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::game::bff::AgentModeMap_ModesEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::bff::AgentModeMap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::bff::AgentModeMap, modes_),
  PROTOBUF_FIELD_OFFSET(::game::bff::ModelWeightsMap_WeightsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::game::bff::ModelWeightsMap_WeightsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::bff::ModelWeightsMap_WeightsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::game::bff::ModelWeightsMap_WeightsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::bff::ModelWeightsMap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::bff::ModelWeightsMap, weights_),
  PROTOBUF_FIELD_OFFSET(::game::bff::ModelBufferMap_BuffersEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::game::bff::ModelBufferMap_BuffersEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::bff::ModelBufferMap_BuffersEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::game::bff::ModelBufferMap_BuffersEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::bff::ModelBufferMap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::bff::ModelBufferMap, buffers_),
  PROTOBUF_FIELD_OFFSET(::game::bff::ModelStatusMap_StatusEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::game::bff::ModelStatusMap_StatusEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::bff::ModelStatusMap_StatusEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::game::bff::ModelStatusMap_StatusEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::bff::ModelStatusMap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::bff::ModelStatusMap, status_),
  PROTOBUF_FIELD_OFFSET(::game::bff::CallDataMap_DataEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::game::bff::CallDataMap_DataEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::bff::CallDataMap_DataEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::game::bff::CallDataMap_DataEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::game::bff::CallDataMap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::game::bff::CallDataMap, data_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::game::bff::ServiceInfo)},
  { 11, -1, -1, sizeof(::game::bff::ServiceIdList)},
  { 18, 26, -1, sizeof(::game::bff::ServiceInfoMap_ServicesEntry_DoNotUse)},
  { 28, -1, -1, sizeof(::game::bff::ServiceInfoMap)},
  { 35, 43, -1, sizeof(::game::bff::ServiceStateMap_StatesEntry_DoNotUse)},
  { 45, -1, -1, sizeof(::game::bff::ServiceStateMap)},
  { 52, 60, -1, sizeof(::game::bff::SimenvConfigMap_ConfigsEntry_DoNotUse)},
  { 62, -1, -1, sizeof(::game::bff::SimenvConfigMap)},
  { 69, 77, -1, sizeof(::game::bff::SimCmdMap_CmdsEntry_DoNotUse)},
  { 79, -1, -1, sizeof(::game::bff::SimCmdMap)},
  { 86, 94, -1, sizeof(::game::bff::SimInfoMap_InfosEntry_DoNotUse)},
  { 96, -1, -1, sizeof(::game::bff::SimInfoMap)},
  { 103, 111, -1, sizeof(::game::bff::AgentConfigMap_ConfigsEntry_DoNotUse)},
  { 113, -1, -1, sizeof(::game::bff::AgentConfigMap)},
  { 120, 128, -1, sizeof(::game::bff::AgentModeMap_ModesEntry_DoNotUse)},
  { 130, -1, -1, sizeof(::game::bff::AgentModeMap)},
  { 137, 145, -1, sizeof(::game::bff::ModelWeightsMap_WeightsEntry_DoNotUse)},
  { 147, -1, -1, sizeof(::game::bff::ModelWeightsMap)},
  { 154, 162, -1, sizeof(::game::bff::ModelBufferMap_BuffersEntry_DoNotUse)},
  { 164, -1, -1, sizeof(::game::bff::ModelBufferMap)},
  { 171, 179, -1, sizeof(::game::bff::ModelStatusMap_StatusEntry_DoNotUse)},
  { 181, -1, -1, sizeof(::game::bff::ModelStatusMap)},
  { 188, 196, -1, sizeof(::game::bff::CallDataMap_DataEntry_DoNotUse)},
  { 198, -1, -1, sizeof(::game::bff::CallDataMap)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::bff::_ServiceInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::bff::_ServiceIdList_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::bff::_ServiceInfoMap_ServicesEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::bff::_ServiceInfoMap_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::bff::_ServiceStateMap_StatesEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::bff::_ServiceStateMap_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::bff::_SimenvConfigMap_ConfigsEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::bff::_SimenvConfigMap_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::bff::_SimCmdMap_CmdsEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::bff::_SimCmdMap_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::bff::_SimInfoMap_InfosEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::bff::_SimInfoMap_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::bff::_AgentConfigMap_ConfigsEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::bff::_AgentConfigMap_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::bff::_AgentModeMap_ModesEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::bff::_AgentModeMap_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::bff::_ModelWeightsMap_WeightsEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::bff::_ModelWeightsMap_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::bff::_ModelBufferMap_BuffersEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::bff::_ModelBufferMap_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::bff::_ModelStatusMap_StatusEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::bff::_ModelStatusMap_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::bff::_CallDataMap_DataEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::game::bff::_CallDataMap_default_instance_),
};

const char descriptor_table_protodef_bff_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\tbff.proto\022\010game.bff\032\013types.proto\032\013agen"
  "t.proto\032\014simenv.proto\"S\n\013ServiceInfo\022\014\n\004"
  "type\030\001 \001(\t\022\014\n\004name\030\002 \001(\t\022\014\n\004host\030\003 \001(\t\022\014"
  "\n\004port\030\004 \001(\r\022\014\n\004desc\030\005 \001(\t\"\034\n\rServiceIdL"
  "ist\022\013\n\003ids\030\001 \003(\t\"\222\001\n\016ServiceInfoMap\0228\n\010s"
  "ervices\030\001 \003(\0132&.game.bff.ServiceInfoMap."
  "ServicesEntry\032F\n\rServicesEntry\022\013\n\003key\030\001 "
  "\001(\t\022$\n\005value\030\002 \001(\0132\025.game.bff.ServiceInf"
  "o:\0028\001\"\221\001\n\017ServiceStateMap\0225\n\006states\030\001 \003("
  "\0132%.game.bff.ServiceStateMap.StatesEntry"
  "\032G\n\013StatesEntry\022\013\n\003key\030\001 \001(\t\022\'\n\005value\030\002 "
  "\001(\0132\030.game.types.ServiceState:\0028\001\"\225\001\n\017Si"
  "menvConfigMap\0227\n\007configs\030\001 \003(\0132&.game.bf"
  "f.SimenvConfigMap.ConfigsEntry\032I\n\014Config"
  "sEntry\022\013\n\003key\030\001 \001(\t\022(\n\005value\030\002 \001(\0132\031.gam"
  "e.simenv.SimenvConfig:\0028\001\"z\n\tSimCmdMap\022+"
  "\n\004cmds\030\001 \003(\0132\035.game.bff.SimCmdMap.CmdsEn"
  "try\032@\n\tCmdsEntry\022\013\n\003key\030\001 \001(\t\022\"\n\005value\030\002"
  " \001(\0132\023.game.simenv.SimCmd:\0028\001\"\200\001\n\nSimInf"
  "oMap\022.\n\005infos\030\001 \003(\0132\037.game.bff.SimInfoMa"
  "p.InfosEntry\032B\n\nInfosEntry\022\013\n\003key\030\001 \001(\t\022"
  "#\n\005value\030\002 \001(\0132\024.game.simenv.SimInfo:\0028\001"
  "\"\221\001\n\016AgentConfigMap\0226\n\007configs\030\001 \003(\0132%.g"
  "ame.bff.AgentConfigMap.ConfigsEntry\032G\n\014C"
  "onfigsEntry\022\013\n\003key\030\001 \001(\t\022&\n\005value\030\002 \001(\0132"
  "\027.game.agent.AgentConfig:\0028\001\"\205\001\n\014AgentMo"
  "deMap\0220\n\005modes\030\001 \003(\0132!.game.bff.AgentMod"
  "eMap.ModesEntry\032C\n\nModesEntry\022\013\n\003key\030\001 \001"
  "(\t\022$\n\005value\030\002 \001(\0132\025.game.agent.AgentMode"
  ":\0028\001\"\224\001\n\017ModelWeightsMap\0227\n\007weights\030\001 \003("
  "\0132&.game.bff.ModelWeightsMap.WeightsEntr"
  "y\032H\n\014WeightsEntry\022\013\n\003key\030\001 \001(\t\022\'\n\005value\030"
  "\002 \001(\0132\030.game.agent.ModelWeights:\0028\001\"\221\001\n\016"
  "ModelBufferMap\0226\n\007buffers\030\001 \003(\0132%.game.b"
  "ff.ModelBufferMap.BuffersEntry\032G\n\014Buffer"
  "sEntry\022\013\n\003key\030\001 \001(\t\022&\n\005value\030\002 \001(\0132\027.gam"
  "e.agent.ModelBuffer:\0028\001\"\216\001\n\016ModelStatusM"
  "ap\0224\n\006status\030\001 \003(\0132$.game.bff.ModelStatu"
  "sMap.StatusEntry\032F\n\013StatusEntry\022\013\n\003key\030\001"
  " \001(\t\022&\n\005value\030\002 \001(\0132\027.game.agent.ModelSt"
  "atus:\0028\001\"\177\n\013CallDataMap\022-\n\004data\030\001 \003(\0132\037."
  "game.bff.CallDataMap.DataEntry\032A\n\tDataEn"
  "try\022\013\n\003key\030\001 \001(\t\022#\n\005value\030\002 \001(\0132\024.game.t"
  "ypes.CallData:\0028\0012\364\013\n\003BFF\022D\n\013ResetServer"
  "\022\031.game.types.CommonRequest\032\032.game.types"
  ".CommonResponse\022G\n\017RegisterService\022\030.gam"
  "e.bff.ServiceInfoMap\032\032.game.types.Common"
  "Response\022H\n\021UnRegisterService\022\027.game.bff"
  ".ServiceIdList\032\032.game.types.CommonRespon"
  "se\022C\n\016GetServiceInfo\022\027.game.bff.ServiceI"
  "dList\032\030.game.bff.ServiceInfoMap\022F\n\016SetSe"
  "rviceInfo\022\030.game.bff.ServiceInfoMap\032\032.ga"
  "me.types.CommonResponse\022C\n\014ResetService\022"
  "\027.game.bff.ServiceIdList\032\032.game.types.Co"
  "mmonResponse\022B\n\014QueryService\022\027.game.bff."
  "ServiceIdList\032\031.game.bff.ServiceStateMap"
  "\022E\n\017GetSimenvConfig\022\027.game.bff.ServiceId"
  "List\032\031.game.bff.SimenvConfigMap\022H\n\017SetSi"
  "menvConfig\022\031.game.bff.SimenvConfigMap\032\032."
  "game.types.CommonResponse\022=\n\nSimControl\022"
  "\023.game.bff.SimCmdMap\032\032.game.types.Common"
  "Response\022;\n\nSimMonitor\022\027.game.bff.Servic"
  "eIdList\032\024.game.bff.SimInfoMap\022C\n\016GetAgen"
  "tConfig\022\027.game.bff.ServiceIdList\032\030.game."
  "bff.AgentConfigMap\022F\n\016SetAgentConfig\022\030.g"
  "ame.bff.AgentConfigMap\032\032.game.types.Comm"
  "onResponse\022\?\n\014GetAgentMode\022\027.game.bff.Se"
  "rviceIdList\032\026.game.bff.AgentModeMap\022B\n\014S"
  "etAgentMode\022\026.game.bff.AgentModeMap\032\032.ga"
  "me.types.CommonResponse\022E\n\017GetModelWeigh"
  "ts\022\027.game.bff.ServiceIdList\032\031.game.bff.M"
  "odelWeightsMap\022H\n\017SetModelWeights\022\031.game"
  ".bff.ModelWeightsMap\032\032.game.types.Common"
  "Response\022C\n\016GetModelBuffer\022\027.game.bff.Se"
  "rviceIdList\032\030.game.bff.ModelBufferMap\022F\n"
  "\016SetModelBuffer\022\030.game.bff.ModelBufferMa"
  "p\032\032.game.types.CommonResponse\022C\n\016GetMode"
  "lStatus\022\027.game.bff.ServiceIdList\032\030.game."
  "bff.ModelStatusMap\022F\n\016SetModelStatus\022\030.g"
  "ame.bff.ModelStatusMap\032\032.game.types.Comm"
  "onResponse\0224\n\004Call\022\025.game.bff.CallDataMa"
  "p\032\025.game.bff.CallDataMapb\006proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_bff_2eproto_deps[3] = {
  &::descriptor_table_agent_2eproto,
  &::descriptor_table_simenv_2eproto,
  &::descriptor_table_types_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_bff_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bff_2eproto = {
  false, false, 3272, descriptor_table_protodef_bff_2eproto, "bff.proto", 
  &descriptor_table_bff_2eproto_once, descriptor_table_bff_2eproto_deps, 3, 24,
  schemas, file_default_instances, TableStruct_bff_2eproto::offsets,
  file_level_metadata_bff_2eproto, file_level_enum_descriptors_bff_2eproto, file_level_service_descriptors_bff_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_bff_2eproto_getter() {
  return &descriptor_table_bff_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_bff_2eproto(&descriptor_table_bff_2eproto);
namespace game {
namespace bff {

// ===================================================================

class ServiceInfo::_Internal {
 public:
};

ServiceInfo::ServiceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:game.bff.ServiceInfo)
}
ServiceInfo::ServiceInfo(const ServiceInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type().empty()) {
    type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_type(), 
      GetArenaForAllocation());
  }
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  host_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_host().empty()) {
    host_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_host(), 
      GetArenaForAllocation());
  }
  desc_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    desc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_desc().empty()) {
    desc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_desc(), 
      GetArenaForAllocation());
  }
  port_ = from.port_;
  // @@protoc_insertion_point(copy_constructor:game.bff.ServiceInfo)
}

inline void ServiceInfo::SharedCtor() {
type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
host_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
desc_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  desc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
port_ = 0u;
}

ServiceInfo::~ServiceInfo() {
  // @@protoc_insertion_point(destructor:game.bff.ServiceInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ServiceInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  host_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  desc_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ServiceInfo::ArenaDtor(void* object) {
  ServiceInfo* _this = reinterpret_cast< ServiceInfo* >(object);
  (void)_this;
}
void ServiceInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ServiceInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ServiceInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:game.bff.ServiceInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  type_.ClearToEmpty();
  name_.ClearToEmpty();
  host_.ClearToEmpty();
  desc_.ClearToEmpty();
  port_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ServiceInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "game.bff.ServiceInfo.type"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "game.bff.ServiceInfo.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string host = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_host();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "game.bff.ServiceInfo.host"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 port = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string desc = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_desc();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "game.bff.ServiceInfo.desc"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServiceInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.bff.ServiceInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string type = 1;
  if (!this->_internal_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "game.bff.ServiceInfo.type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type(), target);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "game.bff.ServiceInfo.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // string host = 3;
  if (!this->_internal_host().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_host().data(), static_cast<int>(this->_internal_host().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "game.bff.ServiceInfo.host");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_host(), target);
  }

  // uint32 port = 4;
  if (this->_internal_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_port(), target);
  }

  // string desc = 5;
  if (!this->_internal_desc().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_desc().data(), static_cast<int>(this->_internal_desc().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "game.bff.ServiceInfo.desc");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_desc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.bff.ServiceInfo)
  return target;
}

size_t ServiceInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.bff.ServiceInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string type = 1;
  if (!this->_internal_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type());
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string host = 3;
  if (!this->_internal_host().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_host());
  }

  // string desc = 5;
  if (!this->_internal_desc().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_desc());
  }

  // uint32 port = 4;
  if (this->_internal_port() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_port());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ServiceInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ServiceInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ServiceInfo::GetClassData() const { return &_class_data_; }

void ServiceInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ServiceInfo *>(to)->MergeFrom(
      static_cast<const ServiceInfo &>(from));
}


void ServiceInfo::MergeFrom(const ServiceInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:game.bff.ServiceInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_type().empty()) {
    _internal_set_type(from._internal_type());
  }
  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (!from._internal_host().empty()) {
    _internal_set_host(from._internal_host());
  }
  if (!from._internal_desc().empty()) {
    _internal_set_desc(from._internal_desc());
  }
  if (from._internal_port() != 0) {
    _internal_set_port(from._internal_port());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ServiceInfo::CopyFrom(const ServiceInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.bff.ServiceInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceInfo::IsInitialized() const {
  return true;
}

void ServiceInfo::InternalSwap(ServiceInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &type_, lhs_arena,
      &other->type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &host_, lhs_arena,
      &other->host_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &desc_, lhs_arena,
      &other->desc_, rhs_arena
  );
  swap(port_, other->port_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ServiceInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bff_2eproto_getter, &descriptor_table_bff_2eproto_once,
      file_level_metadata_bff_2eproto[0]);
}

// ===================================================================

class ServiceIdList::_Internal {
 public:
};

ServiceIdList::ServiceIdList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  ids_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:game.bff.ServiceIdList)
}
ServiceIdList::ServiceIdList(const ServiceIdList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      ids_(from.ids_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:game.bff.ServiceIdList)
}

inline void ServiceIdList::SharedCtor() {
}

ServiceIdList::~ServiceIdList() {
  // @@protoc_insertion_point(destructor:game.bff.ServiceIdList)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ServiceIdList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ServiceIdList::ArenaDtor(void* object) {
  ServiceIdList* _this = reinterpret_cast< ServiceIdList* >(object);
  (void)_this;
}
void ServiceIdList::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ServiceIdList::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ServiceIdList::Clear() {
// @@protoc_insertion_point(message_clear_start:game.bff.ServiceIdList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ids_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ServiceIdList::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string ids = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_ids();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "game.bff.ServiceIdList.ids"));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServiceIdList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.bff.ServiceIdList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string ids = 1;
  for (int i = 0, n = this->_internal_ids_size(); i < n; i++) {
    const auto& s = this->_internal_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "game.bff.ServiceIdList.ids");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.bff.ServiceIdList)
  return target;
}

size_t ServiceIdList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.bff.ServiceIdList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string ids = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(ids_.size());
  for (int i = 0, n = ids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      ids_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ServiceIdList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ServiceIdList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ServiceIdList::GetClassData() const { return &_class_data_; }

void ServiceIdList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ServiceIdList *>(to)->MergeFrom(
      static_cast<const ServiceIdList &>(from));
}


void ServiceIdList::MergeFrom(const ServiceIdList& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:game.bff.ServiceIdList)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  ids_.MergeFrom(from.ids_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ServiceIdList::CopyFrom(const ServiceIdList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.bff.ServiceIdList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceIdList::IsInitialized() const {
  return true;
}

void ServiceIdList::InternalSwap(ServiceIdList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ids_.InternalSwap(&other->ids_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ServiceIdList::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bff_2eproto_getter, &descriptor_table_bff_2eproto_once,
      file_level_metadata_bff_2eproto[1]);
}

// ===================================================================

ServiceInfoMap_ServicesEntry_DoNotUse::ServiceInfoMap_ServicesEntry_DoNotUse() {}
ServiceInfoMap_ServicesEntry_DoNotUse::ServiceInfoMap_ServicesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ServiceInfoMap_ServicesEntry_DoNotUse::MergeFrom(const ServiceInfoMap_ServicesEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ServiceInfoMap_ServicesEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bff_2eproto_getter, &descriptor_table_bff_2eproto_once,
      file_level_metadata_bff_2eproto[2]);
}

// ===================================================================

class ServiceInfoMap::_Internal {
 public:
};

ServiceInfoMap::ServiceInfoMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  services_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:game.bff.ServiceInfoMap)
}
ServiceInfoMap::ServiceInfoMap(const ServiceInfoMap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  services_.MergeFrom(from.services_);
  // @@protoc_insertion_point(copy_constructor:game.bff.ServiceInfoMap)
}

inline void ServiceInfoMap::SharedCtor() {
}

ServiceInfoMap::~ServiceInfoMap() {
  // @@protoc_insertion_point(destructor:game.bff.ServiceInfoMap)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ServiceInfoMap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ServiceInfoMap::ArenaDtor(void* object) {
  ServiceInfoMap* _this = reinterpret_cast< ServiceInfoMap* >(object);
  (void)_this;
  _this->services_. ~MapField();
}
inline void ServiceInfoMap::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena) {
  if (arena != nullptr) {
    arena->OwnCustomDestructor(this, &ServiceInfoMap::ArenaDtor);
  }
}
void ServiceInfoMap::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ServiceInfoMap::Clear() {
// @@protoc_insertion_point(message_clear_start:game.bff.ServiceInfoMap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  services_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ServiceInfoMap::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, .game.bff.ServiceInfo> services = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&services_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServiceInfoMap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.bff.ServiceInfoMap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, .game.bff.ServiceInfo> services = 1;
  if (!this->_internal_services().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::bff::ServiceInfo >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "game.bff.ServiceInfoMap.ServicesEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_services().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_services().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::bff::ServiceInfo >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::bff::ServiceInfo >::const_iterator
          it = this->_internal_services().begin();
          it != this->_internal_services().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = ServiceInfoMap_ServicesEntry_DoNotUse::Funcs::InternalSerialize(1, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::bff::ServiceInfo >::const_iterator
          it = this->_internal_services().begin();
          it != this->_internal_services().end(); ++it) {
        target = ServiceInfoMap_ServicesEntry_DoNotUse::Funcs::InternalSerialize(1, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.bff.ServiceInfoMap)
  return target;
}

size_t ServiceInfoMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.bff.ServiceInfoMap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .game.bff.ServiceInfo> services = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_services_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::bff::ServiceInfo >::const_iterator
      it = this->_internal_services().begin();
      it != this->_internal_services().end(); ++it) {
    total_size += ServiceInfoMap_ServicesEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ServiceInfoMap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ServiceInfoMap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ServiceInfoMap::GetClassData() const { return &_class_data_; }

void ServiceInfoMap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ServiceInfoMap *>(to)->MergeFrom(
      static_cast<const ServiceInfoMap &>(from));
}


void ServiceInfoMap::MergeFrom(const ServiceInfoMap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:game.bff.ServiceInfoMap)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  services_.MergeFrom(from.services_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ServiceInfoMap::CopyFrom(const ServiceInfoMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.bff.ServiceInfoMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceInfoMap::IsInitialized() const {
  return true;
}

void ServiceInfoMap::InternalSwap(ServiceInfoMap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  services_.InternalSwap(&other->services_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ServiceInfoMap::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bff_2eproto_getter, &descriptor_table_bff_2eproto_once,
      file_level_metadata_bff_2eproto[3]);
}

// ===================================================================

ServiceStateMap_StatesEntry_DoNotUse::ServiceStateMap_StatesEntry_DoNotUse() {}
ServiceStateMap_StatesEntry_DoNotUse::ServiceStateMap_StatesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ServiceStateMap_StatesEntry_DoNotUse::MergeFrom(const ServiceStateMap_StatesEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ServiceStateMap_StatesEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bff_2eproto_getter, &descriptor_table_bff_2eproto_once,
      file_level_metadata_bff_2eproto[4]);
}

// ===================================================================

class ServiceStateMap::_Internal {
 public:
};

void ServiceStateMap::clear_states() {
  states_.Clear();
}
ServiceStateMap::ServiceStateMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  states_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:game.bff.ServiceStateMap)
}
ServiceStateMap::ServiceStateMap(const ServiceStateMap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  states_.MergeFrom(from.states_);
  // @@protoc_insertion_point(copy_constructor:game.bff.ServiceStateMap)
}

inline void ServiceStateMap::SharedCtor() {
}

ServiceStateMap::~ServiceStateMap() {
  // @@protoc_insertion_point(destructor:game.bff.ServiceStateMap)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ServiceStateMap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ServiceStateMap::ArenaDtor(void* object) {
  ServiceStateMap* _this = reinterpret_cast< ServiceStateMap* >(object);
  (void)_this;
  _this->states_. ~MapField();
}
inline void ServiceStateMap::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena) {
  if (arena != nullptr) {
    arena->OwnCustomDestructor(this, &ServiceStateMap::ArenaDtor);
  }
}
void ServiceStateMap::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ServiceStateMap::Clear() {
// @@protoc_insertion_point(message_clear_start:game.bff.ServiceStateMap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  states_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ServiceStateMap::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, .game.types.ServiceState> states = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&states_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ServiceStateMap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.bff.ServiceStateMap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, .game.types.ServiceState> states = 1;
  if (!this->_internal_states().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::types::ServiceState >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "game.bff.ServiceStateMap.StatesEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_states().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_states().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::types::ServiceState >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::types::ServiceState >::const_iterator
          it = this->_internal_states().begin();
          it != this->_internal_states().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = ServiceStateMap_StatesEntry_DoNotUse::Funcs::InternalSerialize(1, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::types::ServiceState >::const_iterator
          it = this->_internal_states().begin();
          it != this->_internal_states().end(); ++it) {
        target = ServiceStateMap_StatesEntry_DoNotUse::Funcs::InternalSerialize(1, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.bff.ServiceStateMap)
  return target;
}

size_t ServiceStateMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.bff.ServiceStateMap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .game.types.ServiceState> states = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_states_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::types::ServiceState >::const_iterator
      it = this->_internal_states().begin();
      it != this->_internal_states().end(); ++it) {
    total_size += ServiceStateMap_StatesEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ServiceStateMap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ServiceStateMap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ServiceStateMap::GetClassData() const { return &_class_data_; }

void ServiceStateMap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ServiceStateMap *>(to)->MergeFrom(
      static_cast<const ServiceStateMap &>(from));
}


void ServiceStateMap::MergeFrom(const ServiceStateMap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:game.bff.ServiceStateMap)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  states_.MergeFrom(from.states_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ServiceStateMap::CopyFrom(const ServiceStateMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.bff.ServiceStateMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceStateMap::IsInitialized() const {
  return true;
}

void ServiceStateMap::InternalSwap(ServiceStateMap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  states_.InternalSwap(&other->states_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ServiceStateMap::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bff_2eproto_getter, &descriptor_table_bff_2eproto_once,
      file_level_metadata_bff_2eproto[5]);
}

// ===================================================================

SimenvConfigMap_ConfigsEntry_DoNotUse::SimenvConfigMap_ConfigsEntry_DoNotUse() {}
SimenvConfigMap_ConfigsEntry_DoNotUse::SimenvConfigMap_ConfigsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void SimenvConfigMap_ConfigsEntry_DoNotUse::MergeFrom(const SimenvConfigMap_ConfigsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata SimenvConfigMap_ConfigsEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bff_2eproto_getter, &descriptor_table_bff_2eproto_once,
      file_level_metadata_bff_2eproto[6]);
}

// ===================================================================

class SimenvConfigMap::_Internal {
 public:
};

void SimenvConfigMap::clear_configs() {
  configs_.Clear();
}
SimenvConfigMap::SimenvConfigMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  configs_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:game.bff.SimenvConfigMap)
}
SimenvConfigMap::SimenvConfigMap(const SimenvConfigMap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  configs_.MergeFrom(from.configs_);
  // @@protoc_insertion_point(copy_constructor:game.bff.SimenvConfigMap)
}

inline void SimenvConfigMap::SharedCtor() {
}

SimenvConfigMap::~SimenvConfigMap() {
  // @@protoc_insertion_point(destructor:game.bff.SimenvConfigMap)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SimenvConfigMap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SimenvConfigMap::ArenaDtor(void* object) {
  SimenvConfigMap* _this = reinterpret_cast< SimenvConfigMap* >(object);
  (void)_this;
  _this->configs_. ~MapField();
}
inline void SimenvConfigMap::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena) {
  if (arena != nullptr) {
    arena->OwnCustomDestructor(this, &SimenvConfigMap::ArenaDtor);
  }
}
void SimenvConfigMap::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SimenvConfigMap::Clear() {
// @@protoc_insertion_point(message_clear_start:game.bff.SimenvConfigMap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  configs_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SimenvConfigMap::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, .game.simenv.SimenvConfig> configs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&configs_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SimenvConfigMap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.bff.SimenvConfigMap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, .game.simenv.SimenvConfig> configs = 1;
  if (!this->_internal_configs().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimenvConfig >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "game.bff.SimenvConfigMap.ConfigsEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_configs().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_configs().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimenvConfig >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimenvConfig >::const_iterator
          it = this->_internal_configs().begin();
          it != this->_internal_configs().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = SimenvConfigMap_ConfigsEntry_DoNotUse::Funcs::InternalSerialize(1, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimenvConfig >::const_iterator
          it = this->_internal_configs().begin();
          it != this->_internal_configs().end(); ++it) {
        target = SimenvConfigMap_ConfigsEntry_DoNotUse::Funcs::InternalSerialize(1, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.bff.SimenvConfigMap)
  return target;
}

size_t SimenvConfigMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.bff.SimenvConfigMap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .game.simenv.SimenvConfig> configs = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_configs_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimenvConfig >::const_iterator
      it = this->_internal_configs().begin();
      it != this->_internal_configs().end(); ++it) {
    total_size += SimenvConfigMap_ConfigsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SimenvConfigMap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SimenvConfigMap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SimenvConfigMap::GetClassData() const { return &_class_data_; }

void SimenvConfigMap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SimenvConfigMap *>(to)->MergeFrom(
      static_cast<const SimenvConfigMap &>(from));
}


void SimenvConfigMap::MergeFrom(const SimenvConfigMap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:game.bff.SimenvConfigMap)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  configs_.MergeFrom(from.configs_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SimenvConfigMap::CopyFrom(const SimenvConfigMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.bff.SimenvConfigMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimenvConfigMap::IsInitialized() const {
  return true;
}

void SimenvConfigMap::InternalSwap(SimenvConfigMap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  configs_.InternalSwap(&other->configs_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SimenvConfigMap::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bff_2eproto_getter, &descriptor_table_bff_2eproto_once,
      file_level_metadata_bff_2eproto[7]);
}

// ===================================================================

SimCmdMap_CmdsEntry_DoNotUse::SimCmdMap_CmdsEntry_DoNotUse() {}
SimCmdMap_CmdsEntry_DoNotUse::SimCmdMap_CmdsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void SimCmdMap_CmdsEntry_DoNotUse::MergeFrom(const SimCmdMap_CmdsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata SimCmdMap_CmdsEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bff_2eproto_getter, &descriptor_table_bff_2eproto_once,
      file_level_metadata_bff_2eproto[8]);
}

// ===================================================================

class SimCmdMap::_Internal {
 public:
};

void SimCmdMap::clear_cmds() {
  cmds_.Clear();
}
SimCmdMap::SimCmdMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  cmds_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:game.bff.SimCmdMap)
}
SimCmdMap::SimCmdMap(const SimCmdMap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  cmds_.MergeFrom(from.cmds_);
  // @@protoc_insertion_point(copy_constructor:game.bff.SimCmdMap)
}

inline void SimCmdMap::SharedCtor() {
}

SimCmdMap::~SimCmdMap() {
  // @@protoc_insertion_point(destructor:game.bff.SimCmdMap)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SimCmdMap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SimCmdMap::ArenaDtor(void* object) {
  SimCmdMap* _this = reinterpret_cast< SimCmdMap* >(object);
  (void)_this;
  _this->cmds_. ~MapField();
}
inline void SimCmdMap::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena) {
  if (arena != nullptr) {
    arena->OwnCustomDestructor(this, &SimCmdMap::ArenaDtor);
  }
}
void SimCmdMap::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SimCmdMap::Clear() {
// @@protoc_insertion_point(message_clear_start:game.bff.SimCmdMap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cmds_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SimCmdMap::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, .game.simenv.SimCmd> cmds = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&cmds_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SimCmdMap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.bff.SimCmdMap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, .game.simenv.SimCmd> cmds = 1;
  if (!this->_internal_cmds().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimCmd >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "game.bff.SimCmdMap.CmdsEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_cmds().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_cmds().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimCmd >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimCmd >::const_iterator
          it = this->_internal_cmds().begin();
          it != this->_internal_cmds().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = SimCmdMap_CmdsEntry_DoNotUse::Funcs::InternalSerialize(1, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimCmd >::const_iterator
          it = this->_internal_cmds().begin();
          it != this->_internal_cmds().end(); ++it) {
        target = SimCmdMap_CmdsEntry_DoNotUse::Funcs::InternalSerialize(1, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.bff.SimCmdMap)
  return target;
}

size_t SimCmdMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.bff.SimCmdMap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .game.simenv.SimCmd> cmds = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_cmds_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimCmd >::const_iterator
      it = this->_internal_cmds().begin();
      it != this->_internal_cmds().end(); ++it) {
    total_size += SimCmdMap_CmdsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SimCmdMap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SimCmdMap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SimCmdMap::GetClassData() const { return &_class_data_; }

void SimCmdMap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SimCmdMap *>(to)->MergeFrom(
      static_cast<const SimCmdMap &>(from));
}


void SimCmdMap::MergeFrom(const SimCmdMap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:game.bff.SimCmdMap)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cmds_.MergeFrom(from.cmds_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SimCmdMap::CopyFrom(const SimCmdMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.bff.SimCmdMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimCmdMap::IsInitialized() const {
  return true;
}

void SimCmdMap::InternalSwap(SimCmdMap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  cmds_.InternalSwap(&other->cmds_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SimCmdMap::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bff_2eproto_getter, &descriptor_table_bff_2eproto_once,
      file_level_metadata_bff_2eproto[9]);
}

// ===================================================================

SimInfoMap_InfosEntry_DoNotUse::SimInfoMap_InfosEntry_DoNotUse() {}
SimInfoMap_InfosEntry_DoNotUse::SimInfoMap_InfosEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void SimInfoMap_InfosEntry_DoNotUse::MergeFrom(const SimInfoMap_InfosEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata SimInfoMap_InfosEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bff_2eproto_getter, &descriptor_table_bff_2eproto_once,
      file_level_metadata_bff_2eproto[10]);
}

// ===================================================================

class SimInfoMap::_Internal {
 public:
};

void SimInfoMap::clear_infos() {
  infos_.Clear();
}
SimInfoMap::SimInfoMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  infos_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:game.bff.SimInfoMap)
}
SimInfoMap::SimInfoMap(const SimInfoMap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  infos_.MergeFrom(from.infos_);
  // @@protoc_insertion_point(copy_constructor:game.bff.SimInfoMap)
}

inline void SimInfoMap::SharedCtor() {
}

SimInfoMap::~SimInfoMap() {
  // @@protoc_insertion_point(destructor:game.bff.SimInfoMap)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SimInfoMap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SimInfoMap::ArenaDtor(void* object) {
  SimInfoMap* _this = reinterpret_cast< SimInfoMap* >(object);
  (void)_this;
  _this->infos_. ~MapField();
}
inline void SimInfoMap::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena) {
  if (arena != nullptr) {
    arena->OwnCustomDestructor(this, &SimInfoMap::ArenaDtor);
  }
}
void SimInfoMap::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SimInfoMap::Clear() {
// @@protoc_insertion_point(message_clear_start:game.bff.SimInfoMap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  infos_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SimInfoMap::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, .game.simenv.SimInfo> infos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&infos_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SimInfoMap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.bff.SimInfoMap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, .game.simenv.SimInfo> infos = 1;
  if (!this->_internal_infos().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimInfo >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "game.bff.SimInfoMap.InfosEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_infos().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_infos().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimInfo >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimInfo >::const_iterator
          it = this->_internal_infos().begin();
          it != this->_internal_infos().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = SimInfoMap_InfosEntry_DoNotUse::Funcs::InternalSerialize(1, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimInfo >::const_iterator
          it = this->_internal_infos().begin();
          it != this->_internal_infos().end(); ++it) {
        target = SimInfoMap_InfosEntry_DoNotUse::Funcs::InternalSerialize(1, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.bff.SimInfoMap)
  return target;
}

size_t SimInfoMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.bff.SimInfoMap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .game.simenv.SimInfo> infos = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_infos_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::simenv::SimInfo >::const_iterator
      it = this->_internal_infos().begin();
      it != this->_internal_infos().end(); ++it) {
    total_size += SimInfoMap_InfosEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SimInfoMap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SimInfoMap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SimInfoMap::GetClassData() const { return &_class_data_; }

void SimInfoMap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SimInfoMap *>(to)->MergeFrom(
      static_cast<const SimInfoMap &>(from));
}


void SimInfoMap::MergeFrom(const SimInfoMap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:game.bff.SimInfoMap)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  infos_.MergeFrom(from.infos_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SimInfoMap::CopyFrom(const SimInfoMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.bff.SimInfoMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimInfoMap::IsInitialized() const {
  return true;
}

void SimInfoMap::InternalSwap(SimInfoMap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  infos_.InternalSwap(&other->infos_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SimInfoMap::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bff_2eproto_getter, &descriptor_table_bff_2eproto_once,
      file_level_metadata_bff_2eproto[11]);
}

// ===================================================================

AgentConfigMap_ConfigsEntry_DoNotUse::AgentConfigMap_ConfigsEntry_DoNotUse() {}
AgentConfigMap_ConfigsEntry_DoNotUse::AgentConfigMap_ConfigsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void AgentConfigMap_ConfigsEntry_DoNotUse::MergeFrom(const AgentConfigMap_ConfigsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata AgentConfigMap_ConfigsEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bff_2eproto_getter, &descriptor_table_bff_2eproto_once,
      file_level_metadata_bff_2eproto[12]);
}

// ===================================================================

class AgentConfigMap::_Internal {
 public:
};

void AgentConfigMap::clear_configs() {
  configs_.Clear();
}
AgentConfigMap::AgentConfigMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  configs_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:game.bff.AgentConfigMap)
}
AgentConfigMap::AgentConfigMap(const AgentConfigMap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  configs_.MergeFrom(from.configs_);
  // @@protoc_insertion_point(copy_constructor:game.bff.AgentConfigMap)
}

inline void AgentConfigMap::SharedCtor() {
}

AgentConfigMap::~AgentConfigMap() {
  // @@protoc_insertion_point(destructor:game.bff.AgentConfigMap)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AgentConfigMap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AgentConfigMap::ArenaDtor(void* object) {
  AgentConfigMap* _this = reinterpret_cast< AgentConfigMap* >(object);
  (void)_this;
  _this->configs_. ~MapField();
}
inline void AgentConfigMap::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena) {
  if (arena != nullptr) {
    arena->OwnCustomDestructor(this, &AgentConfigMap::ArenaDtor);
  }
}
void AgentConfigMap::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AgentConfigMap::Clear() {
// @@protoc_insertion_point(message_clear_start:game.bff.AgentConfigMap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  configs_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AgentConfigMap::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, .game.agent.AgentConfig> configs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&configs_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AgentConfigMap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.bff.AgentConfigMap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, .game.agent.AgentConfig> configs = 1;
  if (!this->_internal_configs().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::AgentConfig >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "game.bff.AgentConfigMap.ConfigsEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_configs().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_configs().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::AgentConfig >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::AgentConfig >::const_iterator
          it = this->_internal_configs().begin();
          it != this->_internal_configs().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = AgentConfigMap_ConfigsEntry_DoNotUse::Funcs::InternalSerialize(1, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::AgentConfig >::const_iterator
          it = this->_internal_configs().begin();
          it != this->_internal_configs().end(); ++it) {
        target = AgentConfigMap_ConfigsEntry_DoNotUse::Funcs::InternalSerialize(1, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.bff.AgentConfigMap)
  return target;
}

size_t AgentConfigMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.bff.AgentConfigMap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .game.agent.AgentConfig> configs = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_configs_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::AgentConfig >::const_iterator
      it = this->_internal_configs().begin();
      it != this->_internal_configs().end(); ++it) {
    total_size += AgentConfigMap_ConfigsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AgentConfigMap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AgentConfigMap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AgentConfigMap::GetClassData() const { return &_class_data_; }

void AgentConfigMap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AgentConfigMap *>(to)->MergeFrom(
      static_cast<const AgentConfigMap &>(from));
}


void AgentConfigMap::MergeFrom(const AgentConfigMap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:game.bff.AgentConfigMap)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  configs_.MergeFrom(from.configs_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AgentConfigMap::CopyFrom(const AgentConfigMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.bff.AgentConfigMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AgentConfigMap::IsInitialized() const {
  return true;
}

void AgentConfigMap::InternalSwap(AgentConfigMap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  configs_.InternalSwap(&other->configs_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AgentConfigMap::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bff_2eproto_getter, &descriptor_table_bff_2eproto_once,
      file_level_metadata_bff_2eproto[13]);
}

// ===================================================================

AgentModeMap_ModesEntry_DoNotUse::AgentModeMap_ModesEntry_DoNotUse() {}
AgentModeMap_ModesEntry_DoNotUse::AgentModeMap_ModesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void AgentModeMap_ModesEntry_DoNotUse::MergeFrom(const AgentModeMap_ModesEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata AgentModeMap_ModesEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bff_2eproto_getter, &descriptor_table_bff_2eproto_once,
      file_level_metadata_bff_2eproto[14]);
}

// ===================================================================

class AgentModeMap::_Internal {
 public:
};

void AgentModeMap::clear_modes() {
  modes_.Clear();
}
AgentModeMap::AgentModeMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  modes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:game.bff.AgentModeMap)
}
AgentModeMap::AgentModeMap(const AgentModeMap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  modes_.MergeFrom(from.modes_);
  // @@protoc_insertion_point(copy_constructor:game.bff.AgentModeMap)
}

inline void AgentModeMap::SharedCtor() {
}

AgentModeMap::~AgentModeMap() {
  // @@protoc_insertion_point(destructor:game.bff.AgentModeMap)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AgentModeMap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AgentModeMap::ArenaDtor(void* object) {
  AgentModeMap* _this = reinterpret_cast< AgentModeMap* >(object);
  (void)_this;
  _this->modes_. ~MapField();
}
inline void AgentModeMap::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena) {
  if (arena != nullptr) {
    arena->OwnCustomDestructor(this, &AgentModeMap::ArenaDtor);
  }
}
void AgentModeMap::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AgentModeMap::Clear() {
// @@protoc_insertion_point(message_clear_start:game.bff.AgentModeMap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  modes_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AgentModeMap::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, .game.agent.AgentMode> modes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&modes_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AgentModeMap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.bff.AgentModeMap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, .game.agent.AgentMode> modes = 1;
  if (!this->_internal_modes().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::AgentMode >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "game.bff.AgentModeMap.ModesEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_modes().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_modes().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::AgentMode >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::AgentMode >::const_iterator
          it = this->_internal_modes().begin();
          it != this->_internal_modes().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = AgentModeMap_ModesEntry_DoNotUse::Funcs::InternalSerialize(1, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::AgentMode >::const_iterator
          it = this->_internal_modes().begin();
          it != this->_internal_modes().end(); ++it) {
        target = AgentModeMap_ModesEntry_DoNotUse::Funcs::InternalSerialize(1, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.bff.AgentModeMap)
  return target;
}

size_t AgentModeMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.bff.AgentModeMap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .game.agent.AgentMode> modes = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_modes_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::AgentMode >::const_iterator
      it = this->_internal_modes().begin();
      it != this->_internal_modes().end(); ++it) {
    total_size += AgentModeMap_ModesEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AgentModeMap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AgentModeMap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AgentModeMap::GetClassData() const { return &_class_data_; }

void AgentModeMap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AgentModeMap *>(to)->MergeFrom(
      static_cast<const AgentModeMap &>(from));
}


void AgentModeMap::MergeFrom(const AgentModeMap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:game.bff.AgentModeMap)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  modes_.MergeFrom(from.modes_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AgentModeMap::CopyFrom(const AgentModeMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.bff.AgentModeMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AgentModeMap::IsInitialized() const {
  return true;
}

void AgentModeMap::InternalSwap(AgentModeMap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  modes_.InternalSwap(&other->modes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AgentModeMap::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bff_2eproto_getter, &descriptor_table_bff_2eproto_once,
      file_level_metadata_bff_2eproto[15]);
}

// ===================================================================

ModelWeightsMap_WeightsEntry_DoNotUse::ModelWeightsMap_WeightsEntry_DoNotUse() {}
ModelWeightsMap_WeightsEntry_DoNotUse::ModelWeightsMap_WeightsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ModelWeightsMap_WeightsEntry_DoNotUse::MergeFrom(const ModelWeightsMap_WeightsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ModelWeightsMap_WeightsEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bff_2eproto_getter, &descriptor_table_bff_2eproto_once,
      file_level_metadata_bff_2eproto[16]);
}

// ===================================================================

class ModelWeightsMap::_Internal {
 public:
};

void ModelWeightsMap::clear_weights() {
  weights_.Clear();
}
ModelWeightsMap::ModelWeightsMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  weights_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:game.bff.ModelWeightsMap)
}
ModelWeightsMap::ModelWeightsMap(const ModelWeightsMap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  weights_.MergeFrom(from.weights_);
  // @@protoc_insertion_point(copy_constructor:game.bff.ModelWeightsMap)
}

inline void ModelWeightsMap::SharedCtor() {
}

ModelWeightsMap::~ModelWeightsMap() {
  // @@protoc_insertion_point(destructor:game.bff.ModelWeightsMap)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelWeightsMap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelWeightsMap::ArenaDtor(void* object) {
  ModelWeightsMap* _this = reinterpret_cast< ModelWeightsMap* >(object);
  (void)_this;
  _this->weights_. ~MapField();
}
inline void ModelWeightsMap::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena) {
  if (arena != nullptr) {
    arena->OwnCustomDestructor(this, &ModelWeightsMap::ArenaDtor);
  }
}
void ModelWeightsMap::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelWeightsMap::Clear() {
// @@protoc_insertion_point(message_clear_start:game.bff.ModelWeightsMap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  weights_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelWeightsMap::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, .game.agent.ModelWeights> weights = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&weights_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelWeightsMap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.bff.ModelWeightsMap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, .game.agent.ModelWeights> weights = 1;
  if (!this->_internal_weights().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelWeights >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "game.bff.ModelWeightsMap.WeightsEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_weights().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_weights().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelWeights >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelWeights >::const_iterator
          it = this->_internal_weights().begin();
          it != this->_internal_weights().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = ModelWeightsMap_WeightsEntry_DoNotUse::Funcs::InternalSerialize(1, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelWeights >::const_iterator
          it = this->_internal_weights().begin();
          it != this->_internal_weights().end(); ++it) {
        target = ModelWeightsMap_WeightsEntry_DoNotUse::Funcs::InternalSerialize(1, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.bff.ModelWeightsMap)
  return target;
}

size_t ModelWeightsMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.bff.ModelWeightsMap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .game.agent.ModelWeights> weights = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_weights_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelWeights >::const_iterator
      it = this->_internal_weights().begin();
      it != this->_internal_weights().end(); ++it) {
    total_size += ModelWeightsMap_WeightsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelWeightsMap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelWeightsMap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelWeightsMap::GetClassData() const { return &_class_data_; }

void ModelWeightsMap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelWeightsMap *>(to)->MergeFrom(
      static_cast<const ModelWeightsMap &>(from));
}


void ModelWeightsMap::MergeFrom(const ModelWeightsMap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:game.bff.ModelWeightsMap)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  weights_.MergeFrom(from.weights_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelWeightsMap::CopyFrom(const ModelWeightsMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.bff.ModelWeightsMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelWeightsMap::IsInitialized() const {
  return true;
}

void ModelWeightsMap::InternalSwap(ModelWeightsMap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  weights_.InternalSwap(&other->weights_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelWeightsMap::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bff_2eproto_getter, &descriptor_table_bff_2eproto_once,
      file_level_metadata_bff_2eproto[17]);
}

// ===================================================================

ModelBufferMap_BuffersEntry_DoNotUse::ModelBufferMap_BuffersEntry_DoNotUse() {}
ModelBufferMap_BuffersEntry_DoNotUse::ModelBufferMap_BuffersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ModelBufferMap_BuffersEntry_DoNotUse::MergeFrom(const ModelBufferMap_BuffersEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ModelBufferMap_BuffersEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bff_2eproto_getter, &descriptor_table_bff_2eproto_once,
      file_level_metadata_bff_2eproto[18]);
}

// ===================================================================

class ModelBufferMap::_Internal {
 public:
};

void ModelBufferMap::clear_buffers() {
  buffers_.Clear();
}
ModelBufferMap::ModelBufferMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  buffers_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:game.bff.ModelBufferMap)
}
ModelBufferMap::ModelBufferMap(const ModelBufferMap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  buffers_.MergeFrom(from.buffers_);
  // @@protoc_insertion_point(copy_constructor:game.bff.ModelBufferMap)
}

inline void ModelBufferMap::SharedCtor() {
}

ModelBufferMap::~ModelBufferMap() {
  // @@protoc_insertion_point(destructor:game.bff.ModelBufferMap)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelBufferMap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelBufferMap::ArenaDtor(void* object) {
  ModelBufferMap* _this = reinterpret_cast< ModelBufferMap* >(object);
  (void)_this;
  _this->buffers_. ~MapField();
}
inline void ModelBufferMap::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena) {
  if (arena != nullptr) {
    arena->OwnCustomDestructor(this, &ModelBufferMap::ArenaDtor);
  }
}
void ModelBufferMap::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelBufferMap::Clear() {
// @@protoc_insertion_point(message_clear_start:game.bff.ModelBufferMap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  buffers_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelBufferMap::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, .game.agent.ModelBuffer> buffers = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&buffers_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelBufferMap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.bff.ModelBufferMap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, .game.agent.ModelBuffer> buffers = 1;
  if (!this->_internal_buffers().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelBuffer >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "game.bff.ModelBufferMap.BuffersEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_buffers().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_buffers().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelBuffer >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelBuffer >::const_iterator
          it = this->_internal_buffers().begin();
          it != this->_internal_buffers().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = ModelBufferMap_BuffersEntry_DoNotUse::Funcs::InternalSerialize(1, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelBuffer >::const_iterator
          it = this->_internal_buffers().begin();
          it != this->_internal_buffers().end(); ++it) {
        target = ModelBufferMap_BuffersEntry_DoNotUse::Funcs::InternalSerialize(1, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.bff.ModelBufferMap)
  return target;
}

size_t ModelBufferMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.bff.ModelBufferMap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .game.agent.ModelBuffer> buffers = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_buffers_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelBuffer >::const_iterator
      it = this->_internal_buffers().begin();
      it != this->_internal_buffers().end(); ++it) {
    total_size += ModelBufferMap_BuffersEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelBufferMap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelBufferMap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelBufferMap::GetClassData() const { return &_class_data_; }

void ModelBufferMap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelBufferMap *>(to)->MergeFrom(
      static_cast<const ModelBufferMap &>(from));
}


void ModelBufferMap::MergeFrom(const ModelBufferMap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:game.bff.ModelBufferMap)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  buffers_.MergeFrom(from.buffers_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelBufferMap::CopyFrom(const ModelBufferMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.bff.ModelBufferMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelBufferMap::IsInitialized() const {
  return true;
}

void ModelBufferMap::InternalSwap(ModelBufferMap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  buffers_.InternalSwap(&other->buffers_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelBufferMap::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bff_2eproto_getter, &descriptor_table_bff_2eproto_once,
      file_level_metadata_bff_2eproto[19]);
}

// ===================================================================

ModelStatusMap_StatusEntry_DoNotUse::ModelStatusMap_StatusEntry_DoNotUse() {}
ModelStatusMap_StatusEntry_DoNotUse::ModelStatusMap_StatusEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void ModelStatusMap_StatusEntry_DoNotUse::MergeFrom(const ModelStatusMap_StatusEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata ModelStatusMap_StatusEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bff_2eproto_getter, &descriptor_table_bff_2eproto_once,
      file_level_metadata_bff_2eproto[20]);
}

// ===================================================================

class ModelStatusMap::_Internal {
 public:
};

void ModelStatusMap::clear_status() {
  status_.Clear();
}
ModelStatusMap::ModelStatusMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  status_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:game.bff.ModelStatusMap)
}
ModelStatusMap::ModelStatusMap(const ModelStatusMap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  status_.MergeFrom(from.status_);
  // @@protoc_insertion_point(copy_constructor:game.bff.ModelStatusMap)
}

inline void ModelStatusMap::SharedCtor() {
}

ModelStatusMap::~ModelStatusMap() {
  // @@protoc_insertion_point(destructor:game.bff.ModelStatusMap)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ModelStatusMap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ModelStatusMap::ArenaDtor(void* object) {
  ModelStatusMap* _this = reinterpret_cast< ModelStatusMap* >(object);
  (void)_this;
  _this->status_. ~MapField();
}
inline void ModelStatusMap::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena) {
  if (arena != nullptr) {
    arena->OwnCustomDestructor(this, &ModelStatusMap::ArenaDtor);
  }
}
void ModelStatusMap::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelStatusMap::Clear() {
// @@protoc_insertion_point(message_clear_start:game.bff.ModelStatusMap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  status_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ModelStatusMap::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, .game.agent.ModelStatus> status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&status_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelStatusMap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.bff.ModelStatusMap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, .game.agent.ModelStatus> status = 1;
  if (!this->_internal_status().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelStatus >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "game.bff.ModelStatusMap.StatusEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_status().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_status().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelStatus >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelStatus >::const_iterator
          it = this->_internal_status().begin();
          it != this->_internal_status().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = ModelStatusMap_StatusEntry_DoNotUse::Funcs::InternalSerialize(1, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelStatus >::const_iterator
          it = this->_internal_status().begin();
          it != this->_internal_status().end(); ++it) {
        target = ModelStatusMap_StatusEntry_DoNotUse::Funcs::InternalSerialize(1, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.bff.ModelStatusMap)
  return target;
}

size_t ModelStatusMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.bff.ModelStatusMap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .game.agent.ModelStatus> status = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_status_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::agent::ModelStatus >::const_iterator
      it = this->_internal_status().begin();
      it != this->_internal_status().end(); ++it) {
    total_size += ModelStatusMap_StatusEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ModelStatusMap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ModelStatusMap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ModelStatusMap::GetClassData() const { return &_class_data_; }

void ModelStatusMap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ModelStatusMap *>(to)->MergeFrom(
      static_cast<const ModelStatusMap &>(from));
}


void ModelStatusMap::MergeFrom(const ModelStatusMap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:game.bff.ModelStatusMap)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  status_.MergeFrom(from.status_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ModelStatusMap::CopyFrom(const ModelStatusMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.bff.ModelStatusMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelStatusMap::IsInitialized() const {
  return true;
}

void ModelStatusMap::InternalSwap(ModelStatusMap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  status_.InternalSwap(&other->status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ModelStatusMap::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bff_2eproto_getter, &descriptor_table_bff_2eproto_once,
      file_level_metadata_bff_2eproto[21]);
}

// ===================================================================

CallDataMap_DataEntry_DoNotUse::CallDataMap_DataEntry_DoNotUse() {}
CallDataMap_DataEntry_DoNotUse::CallDataMap_DataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void CallDataMap_DataEntry_DoNotUse::MergeFrom(const CallDataMap_DataEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata CallDataMap_DataEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bff_2eproto_getter, &descriptor_table_bff_2eproto_once,
      file_level_metadata_bff_2eproto[22]);
}

// ===================================================================

class CallDataMap::_Internal {
 public:
};

void CallDataMap::clear_data() {
  data_.Clear();
}
CallDataMap::CallDataMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  data_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:game.bff.CallDataMap)
}
CallDataMap::CallDataMap(const CallDataMap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  data_.MergeFrom(from.data_);
  // @@protoc_insertion_point(copy_constructor:game.bff.CallDataMap)
}

inline void CallDataMap::SharedCtor() {
}

CallDataMap::~CallDataMap() {
  // @@protoc_insertion_point(destructor:game.bff.CallDataMap)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CallDataMap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CallDataMap::ArenaDtor(void* object) {
  CallDataMap* _this = reinterpret_cast< CallDataMap* >(object);
  (void)_this;
  _this->data_. ~MapField();
}
inline void CallDataMap::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena) {
  if (arena != nullptr) {
    arena->OwnCustomDestructor(this, &CallDataMap::ArenaDtor);
  }
}
void CallDataMap::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CallDataMap::Clear() {
// @@protoc_insertion_point(message_clear_start:game.bff.CallDataMap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  data_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CallDataMap::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, .game.types.CallData> data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&data_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CallDataMap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:game.bff.CallDataMap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, .game.types.CallData> data = 1;
  if (!this->_internal_data().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::types::CallData >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
          "game.bff.CallDataMap.DataEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_data().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_data().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::types::CallData >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::types::CallData >::const_iterator
          it = this->_internal_data().begin();
          it != this->_internal_data().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = CallDataMap_DataEntry_DoNotUse::Funcs::InternalSerialize(1, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::types::CallData >::const_iterator
          it = this->_internal_data().begin();
          it != this->_internal_data().end(); ++it) {
        target = CallDataMap_DataEntry_DoNotUse::Funcs::InternalSerialize(1, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:game.bff.CallDataMap)
  return target;
}

size_t CallDataMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:game.bff.CallDataMap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .game.types.CallData> data = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_data_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::game::types::CallData >::const_iterator
      it = this->_internal_data().begin();
      it != this->_internal_data().end(); ++it) {
    total_size += CallDataMap_DataEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CallDataMap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CallDataMap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CallDataMap::GetClassData() const { return &_class_data_; }

void CallDataMap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CallDataMap *>(to)->MergeFrom(
      static_cast<const CallDataMap &>(from));
}


void CallDataMap::MergeFrom(const CallDataMap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:game.bff.CallDataMap)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  data_.MergeFrom(from.data_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CallDataMap::CopyFrom(const CallDataMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:game.bff.CallDataMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CallDataMap::IsInitialized() const {
  return true;
}

void CallDataMap::InternalSwap(CallDataMap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  data_.InternalSwap(&other->data_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CallDataMap::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_bff_2eproto_getter, &descriptor_table_bff_2eproto_once,
      file_level_metadata_bff_2eproto[23]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace bff
}  // namespace game
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::game::bff::ServiceInfo* Arena::CreateMaybeMessage< ::game::bff::ServiceInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::bff::ServiceInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::game::bff::ServiceIdList* Arena::CreateMaybeMessage< ::game::bff::ServiceIdList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::bff::ServiceIdList >(arena);
}
template<> PROTOBUF_NOINLINE ::game::bff::ServiceInfoMap_ServicesEntry_DoNotUse* Arena::CreateMaybeMessage< ::game::bff::ServiceInfoMap_ServicesEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::bff::ServiceInfoMap_ServicesEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::game::bff::ServiceInfoMap* Arena::CreateMaybeMessage< ::game::bff::ServiceInfoMap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::bff::ServiceInfoMap >(arena);
}
template<> PROTOBUF_NOINLINE ::game::bff::ServiceStateMap_StatesEntry_DoNotUse* Arena::CreateMaybeMessage< ::game::bff::ServiceStateMap_StatesEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::bff::ServiceStateMap_StatesEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::game::bff::ServiceStateMap* Arena::CreateMaybeMessage< ::game::bff::ServiceStateMap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::bff::ServiceStateMap >(arena);
}
template<> PROTOBUF_NOINLINE ::game::bff::SimenvConfigMap_ConfigsEntry_DoNotUse* Arena::CreateMaybeMessage< ::game::bff::SimenvConfigMap_ConfigsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::bff::SimenvConfigMap_ConfigsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::game::bff::SimenvConfigMap* Arena::CreateMaybeMessage< ::game::bff::SimenvConfigMap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::bff::SimenvConfigMap >(arena);
}
template<> PROTOBUF_NOINLINE ::game::bff::SimCmdMap_CmdsEntry_DoNotUse* Arena::CreateMaybeMessage< ::game::bff::SimCmdMap_CmdsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::bff::SimCmdMap_CmdsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::game::bff::SimCmdMap* Arena::CreateMaybeMessage< ::game::bff::SimCmdMap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::bff::SimCmdMap >(arena);
}
template<> PROTOBUF_NOINLINE ::game::bff::SimInfoMap_InfosEntry_DoNotUse* Arena::CreateMaybeMessage< ::game::bff::SimInfoMap_InfosEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::bff::SimInfoMap_InfosEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::game::bff::SimInfoMap* Arena::CreateMaybeMessage< ::game::bff::SimInfoMap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::bff::SimInfoMap >(arena);
}
template<> PROTOBUF_NOINLINE ::game::bff::AgentConfigMap_ConfigsEntry_DoNotUse* Arena::CreateMaybeMessage< ::game::bff::AgentConfigMap_ConfigsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::bff::AgentConfigMap_ConfigsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::game::bff::AgentConfigMap* Arena::CreateMaybeMessage< ::game::bff::AgentConfigMap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::bff::AgentConfigMap >(arena);
}
template<> PROTOBUF_NOINLINE ::game::bff::AgentModeMap_ModesEntry_DoNotUse* Arena::CreateMaybeMessage< ::game::bff::AgentModeMap_ModesEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::bff::AgentModeMap_ModesEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::game::bff::AgentModeMap* Arena::CreateMaybeMessage< ::game::bff::AgentModeMap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::bff::AgentModeMap >(arena);
}
template<> PROTOBUF_NOINLINE ::game::bff::ModelWeightsMap_WeightsEntry_DoNotUse* Arena::CreateMaybeMessage< ::game::bff::ModelWeightsMap_WeightsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::bff::ModelWeightsMap_WeightsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::game::bff::ModelWeightsMap* Arena::CreateMaybeMessage< ::game::bff::ModelWeightsMap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::bff::ModelWeightsMap >(arena);
}
template<> PROTOBUF_NOINLINE ::game::bff::ModelBufferMap_BuffersEntry_DoNotUse* Arena::CreateMaybeMessage< ::game::bff::ModelBufferMap_BuffersEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::bff::ModelBufferMap_BuffersEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::game::bff::ModelBufferMap* Arena::CreateMaybeMessage< ::game::bff::ModelBufferMap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::bff::ModelBufferMap >(arena);
}
template<> PROTOBUF_NOINLINE ::game::bff::ModelStatusMap_StatusEntry_DoNotUse* Arena::CreateMaybeMessage< ::game::bff::ModelStatusMap_StatusEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::bff::ModelStatusMap_StatusEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::game::bff::ModelStatusMap* Arena::CreateMaybeMessage< ::game::bff::ModelStatusMap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::bff::ModelStatusMap >(arena);
}
template<> PROTOBUF_NOINLINE ::game::bff::CallDataMap_DataEntry_DoNotUse* Arena::CreateMaybeMessage< ::game::bff::CallDataMap_DataEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::bff::CallDataMap_DataEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::game::bff::CallDataMap* Arena::CreateMaybeMessage< ::game::bff::CallDataMap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::game::bff::CallDataMap >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
